#!/bin/bash
###########################################################
# Author  : william mei
# Date    : 20181010
# version : cfiojobs0.12.53
# Test platform:
#               kernel     : 3.10.0-514.26.2.el7.x86_64
#               OS release : CentOS 7.3.1611
#               Shell type : GNU Bash-4.2
# description  :
#               send files/command to multy host 
#               parallel fio test on clusters 
# last edit :   20181225
###########################################################

script_version=0.12.54
ssh_timeout=15

check_stat=0
tmpfile_dir=$(mktemp -d)
function _clean_up(){
    # clean up tmp files
    sleep $[ssh_timeout * 2]  &&  rm -rf $tmpfile_dir &>/dev/null  &
    for i in ${!tmpfile*} ;do
        local trash_file=$(eval echo \$"$i")
        [[ -f $trash_file ]] && rm -f $trash_file &>/dev/null
    done
}
function _test_abort(){
    # if fio test were started
    if [[ $send_fio == "True" ]]  ;then
        runner=$(whoami)
        # stop fio test 
        [[ -z ${blk_group_list// /} ]] || \
        for blk_group_name in $ $blk_group_list ;do
            [[ -z ${host_group_list// /} ]] || \
            for host_group_name in $host_group_list ;do
                # kill local test process 
                kill $(ps aux |grep $runner |grep "'--fio'" |grep $blk_group_name |grep $host_group_name |grep -v grep|awk '{print$2}') &>/dev/null
            done
        done && wait 
        # bknd ssh process for fio cmd 
        keywords="fio filename= rbdname="
        for kwd in $keywords; do
            kill $(ps aux |grep $runner |grep ssh |grep $kwd |grep -v grep|awk '{print$2}') &>/dev/null
        done
    fi
}
trap "echo -e '\n job stoped with user signals, stop running, please wait ...'; _test_abort; _clean_up; exit $check_stat" 1 2 3 15
#date=$(date "+%Y-%m-%d_%H:%M:%S")
date="$(date +%Y%m%d%H%M)"
g_conf="$0"".grp"
b_conf="$0"".blk"
j_conf="$0"".job"

##############################################################################################
# Global ARRAY:
# declare golbal arrays to common data storage
# 1. blk group
    # all blk group info will be stored in this union array, keywords $blk_group_name.
    declare -A BLK_DEV_ARRAY 
# 2. job group
    #store all job bs/pattern/args in those union array, common keywords $job_group_name
    declare -A VALID_JOB_INFO_ARRAY \
                  JOB_RUNTIME_ARRAY \
                JOB_DATA_SIZE_ARRAY \
                       JOB_BS_ARRAY \
                  JOB_PATTERN_ARRAY \
                     JOB_ARGS_ARRAY 
#   an index array to store all job batchs.
    declare -a      JOB_BATCH_ARRAY \
                    JOB_BATCH_NAME_ARRAY
# a global variable to store all job batchs
#    JOB_BATCH_LIST=""
# 3. host group
    #store all host group info in those union array, common keywords $host_group_name
    declare -A VALID_HOST_GROUP_INFO_ARRAY \
                     HOST_GROUP_USER_ARRAY \
                     HOST_GROUP_PORT_ARRAY \
                     HOST_GROUP_BKND_ARRAY \
                     HOST_GROUP_SH_MODE_ARRAY \
                     HOST_GROUP_IP_LIST_ARRAY 
#
    declare -A       HOST_GROUP_RBD_DEV_ARRAY # host_name 
# a shell array can't contain another array, so set a tmp_delimiter for later access.
#    tmp_delimiter=','
#    OLD_IFS="$IFS"dd
#    tmpfifo=/tmp/tmp."$$"'.fifo'
#
# an output dir list file have all output dir,host group, job group inof stored.
#    echo "" >$0".dirlist"
# temperary history file.
    echo "$(date "+%Y-%m-%d_%H:%M:%S"): $0 $@" >>$0".hst"
##############################################################################################

#help info 
function _show_help_info(){
  echo -e "
This script is a simple fio jobs and file distributor. You can also run commands on multiple hosts with it.
Remenber, you need passwordless SSH access permssions for all hosts, and use a comma as a delimiter when you have multiple group units.

usage :
--------
1. Edit your own host group, block group and fio job type settings in config files.

            (1)     hosts  list conf:   $g_conf
            (2)     blocks list conf:   $b_conf
            (3)     jobs   list conf:   $j_conf

    tips: 

            '$0 -e' will generate example configure files for you

2. Run a short single cmd: 

            $0 <options> [commands]

            options: 
            -t             check host group config file format.
            -g groups      run commands on certain host groups in $g_conf (sep with comma)
            -a             run commands on all host group set
            -x hosts       make an exception on these hosts (sep with comma)
            -X groups      make an exception on these host groups (sep with comma)
            -q             return only exit status of command.(be quiet and less output if no error occurred)
            -d             check and give function parameters, also, skip failure
            -f             skip failure and try to continue, if possible
            -p             send commands and copy files execute in parallel
            --cpid         copy ssh pub id to given host groups 
            --script       execute given scripts on host groups (sep with comma) 
            --argument     pass given arguments(double quote multiple args) to each given script  

    Example: 
   
            $0 -q -g grp1,grp2,grp3,grp4 \"systemctl status sshd ;ls abc\" -x 172.18.211.105
            $0 -q -g grp1,grp2,grp3,grp4 --script ./tmp/install.sh --argument \"-stable\" -x 172.18.211.105

    tips:
    say you want run the command:
    
            'ls -i' 

    you can use: 

            $0 ls -i -g vmg1,grp3 -t -d
      
    it is fine, because '-i' does not confilict with any options supported by this script,
    but still we strongly recommend you write it this way:

            $0 \"ls -i\" -g vmg1,grp3 -t -d

    if you have scripts with different argument to pass in, you'd better execute them separately.

3. Example of Some more complex situation. (how to use double/single quote to pass the complete cmd to script):

        (1).with multy command a time:  
            $0  -g <grp name> \"command1 ;  command2 ;  command3 \"

         with command list to run :  
            $0  -g <grp name> \"command1 && command2 || command3 \"

        (2).with pipe thing or some  :  
            $0  -g <grp name> \"your command |pipe |pipe \"

        (3).with local bash variable :  
            $0  -g <grp name> \"your command \$local_variable \"
            
        (4).with remote env variable :  
            $0  -g <grp name> \"your command '\$remote_env_viriable' \" 

    example: 
            
            $0 -g grp1 \"ls -l |awk '{print\\\$2}'\"
         
    or: 

            $0 -g grp1 \"ls -l |awk \\\"{print"'\\''\\\$2'"}\\\"\"
       
    tips: 

            awk variable is not bash shell variable, so there were three antislash inside curly braces,
            first two antislash passed an '\\' to remote bash, and then the third is for translating the '\$'.

4. FIO jobs control
    
            options:
            --fio          launch a fio test
            --fio-list     output summary info of fio jobs on given host groups
            --fio-stop     stop all existinging fio jobs on given host groups (stop a certain round of jobs in test)
            --test-stop    stop test on given host groups (stop all test and all jobs)
            --recover      recover an undone test form where it was interrupted (aborted, killed or cancled)
            --recover-from recover or restart the test form a given \"round number\" (and a certain \"blk group\")
            --round-list   list all job round info with your test options and arguments (launch no test)
            --round-retest retest a batch of fio jobs with a given \"blk group name\" and \"round number\"
                           the round range like: \"6-9\" or: \"blk8,6-9\" are both ok.
            -c             check test env, (network, ssh connections, fio installation, blk dev to test)
            -b             run fio jobs with given blk group in $b_conf
            -j             run fio job with given job group in $j_conf
            -A             fio task 'After' commands that are given
            -E             run the commands everythime fio test batch starts on a host 
            -o             set the output dir for all fio test logs.
            -s             single block mode, one block a time on each host.
            -S             single group mode, one group a time in the test.
            -l             list all running fio jobs info.
            -r             test on rbd blk.

    example: 

            $0 --fio -g grp1 -b vd5,blk8 -j rand1 -o test01 
            $0 --fio-list -g group1 -p
        
    you can have the current round info from script stdout or log file:
    
            \"<output_dir>/recover.log\", 
    you can easyly recover the test with with a certin round point in test progress, say, to recover the previous test with blk 
    target \"blk8\" and round \"6\", you can use the command :         

            $0 --fio -g grp1 -b vd5,file8 -j rand1 --recover-from blk8,6 -o test01 
        
    or recover a test with only one blk group:
    
            $0 --fio -g grp1 -b vd5 -j rand1,mix1 --recover-from 6 -f -o test02 
    
    or recover the test from where you don't know:
    
            $0 --fio -g grp1 -b vd5 -j rand1,mix1 --recover -f -o test02 
    
    note:
        
            when both the commands and fio jobs were running on a given host, they will be execute in parallel,
            but fio jobs will be send first by default, you can use '-A' to let command execute first.
            $0 --fio -g grp1 -b vd5,blk8 -j rand1,mix1 -A \"umount /dev/vdb\" -o grp1_parallel_test01

    tips:

    **remanber to check the test env befor you start your fio test on a group:**
    
            $0 -g <group name> -f -c

5. File distribution

            options:
            -F files       copy files(sep with comma) to remote host
            -C files       collect files(sep with comma) from remote to local host
            -D dir         specify destination directory on remote host

    example: 
    
            $0 -g grp1 -F file1,file2,file3 -D /tmp/180730/ -x 172.18.211.137

6. Help info

            options:
            -h             show this help info
            -e             make examples of config file (when they do not exist)
            -v, --version  show version info

    If an option requires an argument to work, you are not allowed to combine it with other options,
    you can use :

            $0 -g <group name> -f -c 
            or 
            $0 -g <group name> -fc 

    but the option -g requires an argument of host group name, for this case, you cannot put ~~' -gfc '~~ together!
"
}

function _make_conf_example(){
[[ -f $g_conf ]] && echo "host group config file exist." \
 || cat >$g_conf <<EOF
# The IP address delimiter is a coma ','
# tcmu/ceph backend can be an ip address or 'none' 
#
#grp        user    port    bknd_grps    bknd_mode    ip_addr
grp0        root    5000    grp1         remote       --     # use $(dirname $0)/conf/grp0.grp as ip list 
grp1        root    22      none         none         172.18.211.133,172.18.211.134  #running on esxi 

EOF
[[ -f $b_conf ]] && echo "blk group config file exist."  \
 || cat  >$b_conf <<EOF
# 1. Device delimiter is comma ','.
#list_name  lbk_list/file_list 

# example 1:
sd8         /mnt/sdb/data,/mnt/sdc/data,/mnt/sdd/data,/mnt/sde/data,/mnt/sdf/data,/mntsdg/data,/mnt/sdh/data,/mnt/sdi/data

# example 2:
vd5         /dev/sdb,  #some comment
            /dev/sdc,  #loal disk
            /dev/sdd,  #iscsi disk
            /dev/sde,  #ssd
            /dev/sdf

EOF
[[ -f $j_conf ]] && echo "job group config file exist." \
 ||cat  >$j_conf <<EOF 
# 1. fio arguments delimiter is comma ','.
#    If your are using space as a delimiter for fio job arguments, the "job arguments" must be double quoted!
#    Don't use double quote on the field 1~6. 
#
# 2. "DEFAULT" job should be set before any job group with an empty customized options were writen.
#    If 'inherit_DEFAULT' is 'True' all omitted args will be get from the 'DEFAULT' job set.
#    If 'inherit_DEFAULT' is 'False' this job group will use its own fio arguments.
# 3. only 'json' format log is supported . 
#
#job_name   runtime data_size block_size_range read_write_pattern             inherit_DEFAULT  "fio I/O job arguments"
DEFAULT     600     100%      4k,256k,4m       read,randread,write,randwrite  True             "-group_reporting -direct=1 -iodepth=4  -ioengine=libaio -time_based -numjobs=16 --output-format=json"    
test        600     60G       4k,256k,4m       randread,randwrite             True
durable     172800  100%      none             randrw                         False            "-direct=1  -iodepth=32 -numjobs=4 -bssplit=4k/50:256k/40:4m/10 -ioengine=libaio -rwmixwrite=30 -time_based -group_reporting --output-format=json"
EOF
[[ -f $0".iodepth_bs_pattern.csv" ]] && echo $0".iodepth_bs_pattern.csv" exist. \
||cat >$0".iodepth_bs_pattern.csv" <<EOF
,read,randread,write,randwrite
4k,64,64,64,8
256k,64,64,64,4
4m,64,64,4,6
EOF
}


function _red(){
    echo -e "\e[31m$@\e[0m"
}
function _yellow(){
    echo -e "\e[33m$@\e[0m"
}
function _green(){
    echo -e "\e[32m$@\e[0m"
}
function _blue(){
    echo -e "\e[34m$@\e[0m"
}
function _blink(){
    echo -e "\e[5m$@\e[0m"
}
function _uniq_list(){
# go through all the parameters.
    for i in "$@" ;do
        echo $i 
    #return sorted uniq element in one line.
    done |sort -u |sed ':label;N;s/\n/\ /;b label'
}
function _waiting(){
# wait info $1
# sleep time $2
    # head title 
    echo -en "\n  waiting $1 ...    " 
    local t=$2
    until [[ $t -le 1 ]] ;do
        # bar of second 
        for i in '---' ' \ ' ' | ' ' / ' ;do
            # update bar 
            echo -en "\b\b\b$i" 
            sleep 0.25 
        done
        # sec update 
        t=$(($t -1))
        printf  "%-10s" "$t"
        #clean time info 
        printf  "\b\b\b\b\b\b\b\b\b\b"
    done
    # clean waiting 
    echo -en "\r"
    #sleep 5
    #for ((integer = 1; integer <= 5; integer++));do echo -en "\b\b\b" ;done 
    #echo ""
}
function _timeout(){
# another waiting function.
# show timeout info and wait few secends.
    local t="$1"
    #echo -n "time out in :  "
    echo -e "\npress \"Ctrl + c\" to break here."
    until [[ $t -lt 1 ]] ;do 
        t=$(($t - 1))
        printf  "\r\e[33m%-20s\e[0m" "timeout in $t s"
        sleep 1
    done
    echo -e "\r $1 seconds waiting time out, $(_yellow "skip failed and continue.")\n"
}
function _segline(){
    segment="$@"
    local tty_width=$(tput cols)
    local tag_width=$[tty_width/2 -${#segment}/2]
    delimiter=""
    for i in $(seq 1 $tag_width);do delimiter+='-' ;done
    delimiter+="$segment"
    while [[ ${#delimiter} -lt $tty_width ]] ;do delimiter+='-' ;done
    echo -e "\e[34m$delimiter\e[0m"
}
function _unit_time(){
# add time unit to a time value (sec) int 
    local time_in=${1%%.*}
        if   [[ $time_in -ge 86400 ]] ;then
            time_out=$(echo $time_in |awk '{printf("%.2f\n",$1/86400)}')"Day(s)"
        elif [[ $time_in -ge 3600 ]] ;then
            time_out=$(echo $time_in |awk '{printf("%.2f\n",$1/3600)}')"Hour(s)"
        elif [[ $time_in -ge 60 ]] ;then
            time_out=$(echo $time_in |awk '{printf("%.2f\n",$1/60)}')"Min(s)"
        elif [[ $time_in -ge 0 ]] ;then
            time_out="$time_in"'(s)'
        elif [[ $time_in -lt 0 ]] ;then
#            time_out="confusion!"
            time_out="overtime!"
        fi
        echo "$time_out"
        unset time_out 
}
function _unquiet(){
# give inof when not quiet mode.
    if [[ $quiet_mode == "True" ]] ;then
        # mute 
        return 1
    else 
        # echo 
        echo -e "$@"
    fi
}
function _tmp_quiet(){
    # $1 on/off  
    [[ $quiet_mode == "True"  ]] && QUIET[global]="True"
    if [[ $1 == "on" ]] ;then
        QUIET[local]="True"
    elif [[ $1 == "off" ]] ;then 
        QUIET[local]="False"
    fi
}
function _local_unquiet(){
    # check local .
    if [[ ${QUIET[local]} == "True" ]] ;then
        # mute 
        return 1
    elif [[ ${QUIET[local]} == "False" ]] ;then 
        # echo
        echo -e "$@"
    #check golbal
    else 
        _unquiet "$@"
    fi
}
function _fifo_empty(){
    # check if a pip is read obstructed
    if [[ -n $1 ]] ;then
        fifo_name=$1
        line=255
        read line<$fifo_name &
        p_read=$i 
        sleep 0.25
        if ps ax |grep -q ^$p_read  ;then
            echo 255 >$fifo_name &   
            return 0
        else
            return 1
        fi
    else
        _red "no fifo name recived!"
    fi
}
function _update_check_stat(){
    # add new value to file
    # $1 STAT
    # $2 stat_file
    if [[ -n $2 ]] ;then
        if [[ -f $2 ]] ;then 
            grep -q $1 $2 || echo $1 >>$2
        else
            _verbose "stat file is missing. ${FUNCNAME[@]}"
        fi 
    else
        _verbose "stat file is needed, now it's empty. ${FUNCNAME[@]}"
        # _error_interrupt 
    fi
}
function _error_interrupt(){
#  intterupt script when not debug or no tolerate mode.
#  test with the rest, and wait 3s if need break.
    if [[ $pdebug == "True" ]] ;then
        echo "contunue with test arg \"-d\""
        #wait time out then continue
        _timeout "5"
    elif [[ $tolerate == "True" ]] ;then
        _red "  skip failure and try to continue ..."
    else
    # 2. exit none pdebug
        echo "$(_red " ERROR"): $(date "+%Y-%m-%d_%H:%M:%S"): partially failure occured, script breaks here: $( _yellow "${FUNCNAME[@]:1}")."
        _blue "you can use '-f' or '-d' option to skip the failed part."
        _test_abort && exit 1
    fi
}
# debug tools 
function _marker(){
    _segline "marker $1"
    _blue "function :${FUNCNAME[@]:1}"
}
function _verbose(){
# print info help testing script
# return 1 when pdebug is True
if [[ $pdebug == "True" ]] && [[ -n $1 ]] ;then
    echo "function :${FUNCNAME[@]:1}"
    _blue "info:
##############################################"
    infotype=$1
#---------------------------------------------
    if [[ $infotype == "funcinfo" ]]
then
    :
#---------------------------------------------
    elif [[ $infotype == "roundinfo" ]]
then
_blue "\
 NO. JOB ROUND: $job_batch_index 
 arguments set:\n\t $job_batch \n"
#---------------------------------------------
    elif [[ $infotype == "hostinfo" ]]
then
_blue "\
blk group  name: $blk_group_name
job batch round: $job_batch_index
host group name: $current_host_group 
current    host: $host_ip " 
#---------------------------------------------
    elif [[ $infotype == "jobinfo" ]] 
then
_blue "\
send_fio :$send_fio
blk group:$blk_group_name
job group:$job_group_name
hostgroup:$current_host_group
host ip  :$host_ip
outputdir:$output_dir
log_dir  :$log_dir
log_name :$log_name
test_mode:$test_mode
BLK  name:$BLK
##############################################
$fio_cmd \
-filename=$BLK \
$size_info $rand_arg
-name=$tag-$log_name &>$log_dir/$log_name
"
#---------------------------------------------
    elif [[ $infotype == "bkndinfo" ]] 
then
_blue "\
jobgroup : $job_group_name
runtime  : ${JOB_RUNTIME_ARRAY[$job_group_name]}
tcmu log : $tcmu_logfile
ceph log : $ceph_logfile
"
#---------------------------------------------
    elif [[ $infotype == "bknddetail" ]] 
then
_blue "\
bknd: $bknd_user
ip  : $bknd_ip
port: $bknd_port
"
#---------------------------------------------
    elif [[ $infotype == "groupinfo" ]] 
then
_blue "\
blk group: $blk_group_name
job round: $job_batch_index
job group: $job_group_name
job  name: $job_name
fio   cmd: $fio_cmd
host_user: $host_user
host_port: $host_port
bknd_grps: ${bknd_grps}
bknd_mode: ${bknd_mode}
host list: ${ip_list}
"
#---------------------------------------------
# get from job conf file
    elif [[ $infotype == "expansion" ]] 
then
_blue "\
total Round_No:$total_round, 
inner Round_No:${ground[$job_group_name]}, 
batch   detail:
        fio 
        -bs=$BS 
        -rw=$PATTERN 
        -size=${JOB_DATA_SIZE_ARRAY[$job_group_name]} 
        -runtime=${JOB_RUNTIME_ARRAY[$job_group_name]} 
        ${JOB_ARGS_ARRAY[$job_group_name]} 
"
    fi
#---------------------------------------------
_blue "\
##############################################"
else
    [[ $pdebug == "True" ]] && return 0 || return 1
fi
}
#----------------------------------------|continue here |-----------------------
function _record_fail(){
    if [[ $send_fio == "True" ]] || [[ -n $harvest_file_group_list  ]] ;then
        local failure_time=$(date "+%Y-%m-%d %H:%M:%S")
        local failure_type="${FUNCNAME[1]}" # parent function name 
        [[ ${FUNCNAME[-2]} == "_fio_scale_control" ]] && local failure_stage=${FUNCNAME[-4]} || local failure_stage="${FUNCNAME[-2]}" # the last one is main 
        [[ -z $job_batch_index ]] && failure_note="not in test" || local failure_note="round $job_batch_index"
        echo "$failure_time,$host_group_name,$host_ip,$failure_stage,$failure_type,$failure_note" >>$output_dir/failure_host.csv  
    fi 
}
function _pingfail(){
    # give unreachable host info
    _red "  host:$host_ip unreachable."
    _record_fail
}
function _sshfail(){
    # give ssh connection failed info 
    _red "  host:$host_ip ssh connection failed."
    _record_fail
}
function _devfail(){
    [[ -n $blk ]] && local dev_name=$blk || local dev_name=$BLK 
    # give device check failed info 
    _red "  host:$host_ip dev:$dev_name not a valid test device."
    _record_fail
}

##############################################################################################
# config file check
##############################################################################################
function _format_conf(){
#transform configfile for most config files
    if [[ -z $1 ]] ;then
        echo "${FUNCNAME[@]}: no config file name recived."
        exit 1
    elif [[ ! -f $1 ]] ;then
        echo "${FUNCNAME[@]}: config file $1 not fond."
        exit 1
    else
        configfile="$1"
    fi
# replace:
    # 1. table with space
    # 2. continuous multiple spaces with one space
# removed:
    # 1. empty line and comment.
    # 2. space/tab in head of line
    # 3. comment in end of line
    # 4. space/tab after a comma 
    # 5. space/tab between comma and the line end '\n'
    # 6. cancle line switch, by remove '\n' after comma
    grep -vE "^$|^#" $configfile \
    |sort -u \
    |sed -e 's/\t\+/\ /g' \
         -e 's/[ ]\+/\ /g' \
         -e 's/^[ ]\+//g' \
         -e 's/^\t\+//g' \
         -e 's/#.*$//g' \
         -e 's/\,[ ]*$/\,/g' \
         -e 's/\,[ ]*/\,/g' \
         -e 's/\,[\t]*$/\,/g' \
         -e 's/\,[\t]*/\,/g' \
    |sed -e ':\,;N;s/\,\n/\,/;b \,'
}
function _check_ip(){
# input : an ip address
    ip="$1"
        #pure number and dot
        if echo $ip |grep -q [^0-9,'.'] ;then
            return 1
        #not 0 started
        elif echo $ip |grep -q ^0 ;then
            return 1
        #less than 256
        else 
            for net in $(echo $ip |sed s/\\./\ /g) ;do
                if [[ $net -gt 255 ]] ;then
                    return 1
                fi
            done
        fi
        return 0
}
function _check_port(){
# input : a ssh port number
    if echo $1 |grep -q [^0-9] || [[ $1 -ge 65535 ]] ;then
       return 1
   else
       return 0
    fi 
}
function _grp_conf_check(){
    if [ -f $g_conf ] ;then
        #check start.
        local dublicated_name=$(_format_conf $g_conf |awk '{print$1}' |uniq -d)
        if [[ -n $dublicated_name ]] ;then
            echo "group name conflicted: $(_red "$dublicated_name")"
            exit 1
        fi
        #echo "$(_format_conf $g_conf)"
        index_name_array=("host group name" "ssh user" "ssh port" "backend group" "bknd execute mode" "host ip list")
        #read line with 7 fields
        while read f1 f2 f3 f4 f5 f6 f7 ;do
            missing_info=''
            #skip empty line
            local group_info=($f1 $f2 $f3 $f4 $f5 $f6 $f7)
            for index in {1..5} ;do 
                if [[ -z ${group_info[$index]} ]] ;then
                    local missing_info+=" ${index_name_array[$index]},"
                elif [[ $index -eq 2 ]] ;then 
                    if _check_port ${group_info[$index]} ;then
                        :
                    else 
                        echo "group :$f1, illegal ssh port ${group_info[$index]} "
                        local check_stat=1 
                    fi
                elif [[ $index -eq 5 ]] && [[ ${group_info[$index]} == "--" ]] ;then
                    local grp_file=$(dirname $0)/conf/$f1'.grp'
                    if [[ -f $grp_file ]] ;then
                        for i in  $(_format_conf $grp_file);do
                            if ! _check_ip $i ;then
                                echo "group :$f1, illegal ip format $i"
                                local check_stat=1 
                            fi
                        done
                    fi
                fi 
            done
            [[ -n $missing_info ]] && echo "group :$f1, missing $missing_info info" && local check_stat=1
        done  << EOF
$(_format_conf $g_conf)
EOF
        [[ $check_stat -ne 1 ]] && echo "host group config file checked ok." || exit 1
    else
        echo "host list file not fond."
    fi
}
function _blk_conf_check(){
    _blue "${FUNCNAME[@]} is on the way ... 0_="
}
function _job_conf_check(){
    _blue "${FUNCNAME[@]} is on the way ... 0_="
}

##############################################################################################
# user input check
##############################################################################################
#check host,blk,fio jobs list from input
#group name expansion and check

function _get_all_host_group(){
    host_group_list+=$(_format_conf $g_conf \
        |awk '{print$1}' \
        |sed ':label;N;s/\n/\ /;b label'
    )
}
function _group_check(){
    # $1 host_group_name
    local host_group_name=$1
    local index_name_array=("host group name" "ssh user" "ssh port" "backend group" "backend script execute mode" "host ip list")
        #get group info from conf file with keywords in column one.
        local group_info=($(_format_conf $g_conf |grep ^$host_group_name[' '] ))
                # 1. group_info check, more then 4 culumns, 
                if [[ ${#group_info[@]} -gt 5 ]] ;then
                # 2. if no missing columns, store into global array
                       VALID_HOST_GROUP_INFO_ARRAY[$host_group_name]=${group_info[@]}
                             HOST_GROUP_USER_ARRAY[$host_group_name]=${group_info[1]}
                             HOST_GROUP_PORT_ARRAY[$host_group_name]=${group_info[2]}
                             HOST_GROUP_BKND_ARRAY[$host_group_name]=${group_info[3]//,/ }
                          HOST_GROUP_SH_MODE_ARRAY[$host_group_name]=${group_info[4]}
                    # find ip list in config dir "conf/xxx.grp"
                    if [[ ${group_info[5]} == '--' ]] ;then
                        local host_conf=$(dirname $0)/conf/$host_group_name".grp"
                        if [[ -f $host_conf ]] ;then
                            HOST_GROUP_IP_LIST_ARRAY[$host_group_name]=$(_uniq_list $(_format_conf $host_conf ))
                        else
                            echo "Warning: host group config file: $g_conf, group name: \"$host_group_name\" , ip list file: \"$host_conf\" is missing "
                        fi
                    else
                          HOST_GROUP_IP_LIST_ARRAY[$host_group_name]=$(_uniq_list ${group_info[5]//,/ })
                    fi
    #echo ${HOST_GROUP_IP_LIST_ARRAY[$host_group_name]}
                else
                # if group info lost, skip or exit
                # 3. check from last, find last missing info index, and print its name.
                    for index in {1..5} ;do
                       [[ -z ${group_info[$index]} ]] && echo "Warning: host group config file: $g_conf, group name: \"$host_group_name\" , ${index_name_array[$index]} info missing!"
                    done
                    grp_stat=1
                    # remove from host_group_list
                    host_group_list=${host_group_list/$host_group_name/}
                    _error_interrupt
                fi
            #group check done
}
function _host_group_check(){
#veirify all host group from input, then store in array
# grp_stat, 0: ok, 1: part failed, 2: all failed.
    grp_stat=0
    if [[ -n ${host_group_list} ]] ;then
        host_group_list=$(_uniq_list $host_group_list)
        #calculating group name and ip list
        # remove exceptions
        if [[ -n $x_group_list ]] ;then
            x_group_list=$(_uniq_list $x_group_list)
            for x_group in $x_group_list ;do
                host_group_list=${host_group_list/$x_group/}
            done
        fi
    #check group result after remove X group
        if [[ -n ${host_group_list// /} ]] ;then
            #validate every host group availability
            for host_group_name in ${host_group_list} ;do 
                _group_check $host_group_name 
            done
            #after group check, if valid host group exists
            if [[ -z ${host_group_list// /} ]] ;then
                grp_stat=2
                echo "no valid host group!"
            fi
        else
        #no valid group left after remove X group
            _red "no valid host group!"
            grp_stat=2
        fi
    else
    #no group input captured
        grp_stat=2
        _red "no host group name revived."
        exit 1
    fi
}
function _job_group_check(){
#verify job group and get fio arguments merged, then store in array
# job_stat, 0: ok, 1: part failed, 2: all failed.
    job_stat="0"
    #get default job info array
    DEFAULT_INFO=($(_format_conf $j_conf |grep ^DEFAULT[' '] ))
        #check args were double quoted
        [[ ${DEFAULT_INFO[6]} =~ '"' ]] && \
        DEFAULT_INFO[6]=$(_format_conf $j_conf |grep ^DEFAULT[' '] |cut -d'"' -f2) || \
        DEFAULT_INFO[6]="${DEFAULT_INFO[6]//,/ }"
    #an array of element names for all job group
    index_name_array=("job group name" "job runtime" "test data size" "block size" "test pattern" "inherit_DEFAULT" "customized fio args")
    #list checking work
    if [[ -n ${job_group_list} ]] ;then
        job_group_list=$(_uniq_list $job_group_list)
        # 01 every job group, info check.
        for job_group_name in $job_group_list ;do
            # get its info
            if _format_conf $j_conf | grep -q ^$job_group_name[' '] ;then
                :
            else
                # skip invalid
                job_group_list=${job_group_list//$job_group_name/}
                continue
            fi
            job_group_info=($(_format_conf $j_conf |grep ^$job_group_name[' '] ))
                #check args were double quoted
                [[ ${job_group_info[6]} =~ '"' ]] && \
                job_group_info[6]=$(_format_conf $j_conf |grep ^$job_group_name[' '] |cut -d'"' -f2) || \
                job_group_info[6]="${job_group_info[6]//,/ }"
            # 1. job group info must more than 6 element, index 0-5.
            if [[ ${#job_group_info[@]} -lt 6 ]] ;then
                # check failed, remove it from blk group list, update grp_stat
                job_stat=1
                job_group_list=${job_group_list/$job_group_name/}
                # check missing array element. check from the last, which element is missing.
                # if index2 is missing index3 will be take as index2, so always find the last missing index, index 1-5
                for index in {1..5} ;do
                   [[ -z ${job_group_info[$index]} ]] && echo "Warning: job group config file: $j_conf, $job_group_name: ${index_name_array[$index]} info missing!"
                done
                _error_interrupt
            else
            # 2. if info ok, args calculating, check if use default
                # if use default, merge default fio args
                if [[ ${job_group_info[5]} == "True" ]] ;then 
                    # DEFAULT arg iterm check and add to this job group
                    for iterm in ${DEFAULT_INFO[6]} ;do
                        [[ "${job_group_info[6]}" =~ "${iterm%%=*}" ]] || job_group_info[6]+=" ${iterm}"
                    done
                # if not use default, doing nothing, just keep its own.
                fi
            # 3. after calculation, save valid group info to global arrays for common access
               VALID_JOB_INFO_ARRAY[$job_group_name]="${job_group_info[@]:0:7}"
                  JOB_RUNTIME_ARRAY[$job_group_name]="${job_group_info[1]}"
                JOB_DATA_SIZE_ARRAY[$job_group_name]="${job_group_info[2]}"
                       JOB_BS_ARRAY[$job_group_name]="${job_group_info[3]//,/ }"
                  JOB_PATTERN_ARRAY[$job_group_name]="${job_group_info[4]//,/ }"
                     JOB_ARGS_ARRAY[$job_group_name]="${job_group_info[6]}"
            fi
            # options should be started with '-'
            for iterm in ${job_group_info[6]} ;do
                [[ ${iterm:0:1} != '-' ]] && _yellow "job group name: $job_group_name, loose fio option found: \"${iterm}\"" && _timeout 15
            done
        #   04 exit or skip if any job group info missing.
                job_stat="1"
        #  group check done
        done
    #   after group check, if valid job groups exists
        if [[ -z ${job_group_list// /} ]] ;then
            job_stat="2"
            _red "no valid job group!"
            exit 1
        fi
        [[ $(echo $job_group_list |wc -w) -gt 1 ]] && multy_job_group="True"
    #
    else
        job_stat="2"
        _red "No job group name recived."
        exit 1
    fi
}
function _blk_group_check(){
#verify blk group from input, then store in array
# blk_stat, 0: ok, 1: part failed, 2: all failed.
    blk_stat="0"
    #none empty list
    if [[ -n ${blk_group_list// /} ]];then
        blk_group_list=$(_uniq_list $blk_group_list)

        # every blk, group info check
        for blk_group_name in $blk_group_list ;do
            # 1. if found in conf
#echo "check result"
#_format_conf $b_conf 
#_format_conf $b_conf |grep ^$blk_group_name[' ']
#echo "pre check result"
#_format_conf $b_conf |grep ^[' ']*$blk_group_name[' ']
#sleep 30
            if _format_conf $b_conf |grep -q ^[' ']*$blk_group_name[' '] ;then
            # 2. device list existence
                #get blk_list info put in a array
                blk_group_info=($(_format_conf $b_conf |grep ^$blk_group_name[' '] ))
#echo "${blk_group_info[@]}"
                if [[ -z ${blk_group_info[1]} ]] ;then
                    #no device list, remove from blk group list, update blk group stat
                    blk_stat="1"
                    blk_group_list=${blk_group_list/$blk_group_name/}
                    # give info which is missing.
                    echo "blk group: $blk_group_name, device list info is missing!"
                    # if test with the rest group
                    _error_interrupt
                else
            # 3. after check no part missing, store device list of this blk group in global array.
                BLK_DEV_ARRAY[$blk_group_name]=${blk_group_info[1]//,/ }
                fi
            elif [[ -f $(dirname $0)/conf/$blk_group_name".blk" ]] ;then
                # check blk config and add blk info to array 
                blk_group_info[1]=$(_format_conf $(dirname $0)/conf/$blk_group_name".blk")
                blk_group_info[1]=$(_uniq_list ${blk_group_info[1]})
                [[ -n ${blk_group_info[1]//,/} ]] && BLK_DEV_ARRAY[$blk_group_name]=${blk_group_info[1]//,/ }
            # 1.2 name missing in conf
            else
            #remove the invalid group which its name not exist in conf
                echo "Warning: blk config file: $b_conf, $blk_group_name: device list info is missing!"
                blk_stat="1"
                blk_group_list=${blk_group_list/$blk_group_name/}
                # skip missing test with the rest group
                _error_interrupt
            fi
            #sleep 30
        #check done
        done
        # after all checked, if available blk_group exist
        if [[ -z ${blk_group_list// /} ]] ;then
            blk_stat="2"
            _red "no valid blk groups."
        fi
        [[ $(echo $blk_group_list |wc -w) -gt 1 ]] && multy_blk_group="True"
    else
    #empty list
    #[[ -f $(dirname $0)/conf/ ]]
        #if [[ $no_sys_blk != "True" ]] ;then
            blk_stat="2"
            _red "no blk group name recived."
            exit 1
        #fi
    fi
}
function _recover_point_check(){
    # confilict check.
    [[ $recover_test == "True" ]] && [[ $round_retest == "True" ]] && echo "Parameter confusion!" && exit 1
    # recover or retest.
    if  [[ $recover_test == "True" ]] || [[ $round_retest == "True" ]] ;then 
        if [[ $recover_test == "True" ]] ;then
            # recover_blk_group_name might be empty 
            # recover_job_batch_index cannot be empty 
            if [[ -z $recover_job_batch_index ]] ;then
                # check recover log file 
                if [[ ! -f $output_dir/recover.log ]] ;then
                    _yellow "Recover log file: \"$output_dir/recover.log\" is missing!"
                    echo "Perhapes the test ended too early or it's all done, You can restart the test but it cant't be recovered."
                    exit 1
                fi
                recover_info=$(sed -n 1p $output_dir/recover.log)
                recover_blk_group_name=${recover_info%,*}
                recover_job_batch_index=${recover_info##*,}
            fi
            # give recover info 
            _blue "Test recovering..."
        elif [[ $round_retest == "True" ]] ;then 
            _blue "Round retest starting..."
        fi
        # check format and give info 
        if [[ ${recover_job_batch_index//[^0-9,-]/} != $recover_job_batch_index ]] ;then
            echo "$recover_job_batch_index: recover_job_batch_index format error!"
            exit 1
        fi
        [[ -z $recover_blk_group_name ]] && local b_name="omited" || local b_name=\"$recover_blk_group_name\"
        _blue "recover point: blk_group_name: $b_name, job_batch_index: \"$recover_job_batch_index\""
    fi 
}
function _recover_blk_group(){
                # recover 
                [[ $recover_test == "True" ]] && [[ -n $recover_blk_group_name ]] && [[ $blk_group_name != $recover_blk_group_name ]] && continue 
                # clean recover info after recovery
                [[ $recover_test == "True" ]] && recover_blk_group_name=""
                #_blue "recover from blk group: $blk_group_name"

                # round retest 
                [[ $round_retest == "True" ]] && [[ -n $recover_blk_group_name ]] && [[ $blk_group_name != $recover_blk_group_name ]] && continue 
}
function _recover_job_batch(){
                # recover  
                [[ $recover_test == "True" ]] && [[ -n $recover_job_batch_index ]] && [[ $job_batch_index != $recover_job_batch_index ]] && continue 
                # clean recover info after recovery
                [[ $recover_test == "True" ]] && recover_job_batch_index="" && recover_test="False"
                # set new recover_info 
                echo "$blk_group_name,$job_batch_index" > $output_dir/recover.log
                #_blue "recover test batch from job Round_No: $job_batch_index"

                # round retest 
            if [[ ${recover_job_batch_index/-/} == ${recover_job_batch_index} ]] ;then 
                [[ $round_retest == "True" ]] && [[ -n $recover_job_batch_index ]] && [[ $job_batch_index != $recover_job_batch_index ]] && continue 
            else 
                [[ $round_retest == "True" ]] && [[ -n $recover_job_batch_index ]] && [[ $job_batch_index -lt ${recover_job_batch_index%-*} ]] && continue 
                [[ $round_retest == "True" ]] && [[ -n $recover_job_batch_index ]] && [[ $job_batch_index -gt ${recover_job_batch_index#*-} ]] && continue 
            fi 
}
##############################################################################################
# task preparation.
##############################################################################################
# 1. a blk group can not be shared for different scale of fio test at the same time,
#    but the job groups and the host groups can be shared by different scale of test.
# 2. build a job batch list with all available job groups, contains each round of job.
# 3. distribute jobs to host groups, different host groups may have different user and port settings
function _rbd_expansion(){
    # $1 host_group_name 
    # $blk_group_name set 
    local all_ip_list=''
    if [[ -z $1 ]] ;then
        for i in $host_group_list;do
            all_ip_list+=" ${HOST_GROUP_IP_LIST_ARRAY[$i]}"
        done
    else
        all_ip_list="${HOST_GROUP_IP_LIST_ARRAY[$1]}"
    fi 
    all_ip_list=$(_uniq_list $all_ip_list)
    # HOST_GROUP_IP_LIST_ARRAY
    # HOST_GROUP_RBD_DEV_ARRAY 
    # cleanning up array for current host group 
# if an array declared in a function, it will a local array for bash shell.
    #unset HOST_GROUP_RBD_DEV_ARRAY 
    #declare -A HOST_GROUP_RBD_DEV_ARRAY # host_name 
    for k in ${HOST_GROUP_RBD_DEV_ARRAY[*]};do
        [[ -n $k ]] && HOST_GROUP_RBD_DEV_ARRAY[$k]=''
    done
    local rbd_list=${BLK_DEV_ARRAY[$blk_group_name]} 
    #local hst_list=${HOST_GROUP_IP_LIST_ARRAY[$1]}
    # count rbd_numbere
    local rbd_nu=$(echo $rbd_list |wc -w)
    # count host number 
    #local hst_nu=$(echo $hst_list |wc -w)
    local hst_nu=$(echo $all_ip_list |wc -w)
    # 
    if [[ $hst_nu -ge $rbd_nu ]] ;then 
        # rbd less then host 
        local dsb_nu=1
    else
        local dsb_nu=$(($rbd_nu / $hst_nu))
    fi
    # 
    #echo "rbd:$rbd_nu hst:$hst_nu dsb:$dsb_nu"
    local host_name=''
    for host_name in $all_ip_list ;do
        HOST_GROUP_RBD_DEV_ARRAY[$host_name]=''
    done
    for host_name in $all_ip_list ;do
        #echo "host: $host_name"
        for rbd_name in $rbd_list ;do
            # rbd001 
            #echo "rbd: $rbd_name hst rbd nu:$(echo ${HOST_GROUP_RBD_DEV_ARRAY[$host_name]} |wc -w)"
            if test $(echo ${HOST_GROUP_RBD_DEV_ARRAY[$host_name]} |wc -w) -lt $dsb_nu ;then 
                HOST_GROUP_RBD_DEV_ARRAY[$host_name]+=" $rbd_name" 
                rbd_list=${rbd_list/$rbd_name/}
            else
                break 
            fi
        done
    done
    if [[ $(( $rbd_nu % $hst_nu )) -ne 0 ]];then
        #
        for host_name in $all_ip_list;do
            #
            for rbd_name in $rbd_list ;do
                HOST_GROUP_RBD_DEV_ARRAY[$host_name]+=" $rbd_name" 
                rbd_list=${rbd_list/$rbd_name/}
                break 
            done
        done
    fi
    if _verbose || [[ $round_list == "True" ]] ;then 
        if [[ -n $1 ]] ;then 
            local i="host group: $host_group_name" 
        else
            #_blue "\ngroup parallel test expansion"
            local i="host groups: ${host_group_list// /, }" 
        fi 
        _yellow "\nRBD Distribution Info:"
        _blue "blk group: $blk_group_name, $i"
#echo keys: ${!HOST_GROUP_RBD_DEV_ARRAY[*]}
#echo host: $all_ip_list
        for k in ${all_ip_list};do
            printf "%-24s%-15s\n" "host: ${k}" "| ${HOST_GROUP_RBD_DEV_ARRAY[$k]}"
        done
        echo ''
    fi
}
function _show_rbd_expansion(){
    #test _rbd_expansion 
    if [[ $rbd_mode == "True" ]] ;then 
        if [[ $group_mode == "single" ]];then
            for blk_group_name in $blk_group_list;do 
                for host_group_name in $host_group_list;do
                    _rbd_expansion $host_group_name 
                done
            done
        else
            _rbd_expansion 
        fi
    fi 
}
function _get_iodepth_from_table(){
    _blue "${FUNCNAME[@]} is on the way ... 0_=" && exit 1
# get iodepth from a table with bs and pattern axis.
    iodepth_bs_pattern_table="$1"
    [[ ! -f "$iodepth_bs_pattern_table" ]] \
     && echo "$(date "+%Y-%m-%d_%H:%M:%S") ${FUNCNAME[@]} $iodepth_bs_pattern_table not fond !" \
     && exit 1
    declare -A col_no
    col_no[read]=2
    col_no[randread]=3
    col_no[write]=4
    col_no[randwrite]=5
    colume=${col_no[$PATTERN]}
#give iodepth from table
    IODEPTH=$(grep $BS $iodepth_bs_pattern_table |cut -d',' -f $colume)
    echo "$IODEPTH"
}
function _give_size(){
    #if [[ ${JOB_DATA_SIZE_ARRAY[$job_group_name]} == "none" ]] ;then
    #    :
    if [[ ${JOB_DATA_SIZE_ARRAY[$job_group_name]} == "random" ]] ;then
        :
    else
        echo "-size=${JOB_DATA_SIZE_ARRAY[$job_group_name]}"
    fi
}
function _give_runtime(){
    if [[ ${JOB_RUNTIME_ARRAY[$job_group_name]} != "none" ]] ;then
        echo "-runtime=${JOB_RUNTIME_ARRAY[$job_group_name]}"
    fi
}
function _give_bs(){
    if [[ $BS != "none" ]] ;then
        echo "-bs=$BS"
    #else
    #    :
    fi
}
function _fio_job_expansion(){
# generate job batch for blk group to build scale test, and send to  host group to execute.
# expanted based on: job_group_name --> BS --> PATTERN 
#                    they will be stored in a global name array.
    total_round=0
    local runtime_sum=""
    declare -A ground gtime
    _verbose && _yellow "job group expansion:"
    for job_group_name in $job_group_list ;do
        #count round number and basic time costs for group.
        ground[$job_group_name]=0
        gtime[$job_group_name]=0
#        echo ${VALID_JOB_INFO_ARRAY[$job_group_name]}
        for BS in ${JOB_BS_ARRAY[$job_group_name]} ;do
            for PATTERN in ${JOB_PATTERN_ARRAY[$job_group_name]} ;do
                #update round number
                total_round=$(($total_round + 1))
                ground[$job_group_name]=$(( ${ground[$job_group_name]} + 1 ))
                #update time for group
                gtime[$job_group_name]=$(( ${JOB_RUNTIME_ARRAY[$job_group_name]} * ${ground[$job_group_name]} / 60 )) 
                #update runtime_sum
                [[ -z $runtime_sum ]] && runtime_sum=${JOB_RUNTIME_ARRAY[$job_group_name]}  || runtime_sum=$((${JOB_RUNTIME_ARRAY[$job_group_name]} + $runtime_sum ))
                #pdebug info
                _verbose "expansion" && _waiting "reading" 5
                #store job batch in global list
                JOB_BATCH_ARRAY[$total_round]="\
fio \
$(_give_runtime) \
$(_give_size) \
$(_give_bs) \
-rw=$PATTERN \
${JOB_ARGS_ARRAY[$job_group_name]} "
                JOB_BATCH_NAME_ARRAY[$total_round]=$job_group_name-$BS-$PATTERN
            done
        done
    done
    # round info 
    if _verbose || [[ $round_list == "True" ]] ;then 
        _yellow "job time caculation:"
        echo -e "\tall job group will lunch $total_round fio jobs, and costs $(($runtime_sum / 60 + $(($total_round/ 2)) )) minites on a single host at least.\n"
        for job_group_name in $job_group_list ;do
            echo -e "\tjob group: \"$job_group_name\" will lunch ${ground[$job_group_name]} round of jobs, costs $((${gtime[$job_group_name]} + $((${ground[$job_group_name]}/2)) )) minites at least."
        done
        # make a list of job batch info 
        local tmpfile_expansion=$(mktemp -p $tmpfile_dir)
        local title="NO"
        local batch="PATTERN"
        if [[ $total_round -le 10 ]];then 
            for index in $(seq 1 $total_round);do
            #
                title+=",$index"
                batch+=",${JOB_BATCH_NAME_ARRAY[$index]}"
            done
            echo -e "$title\n$batch" >$tmpfile_expansion
        else
            for index in $(seq 1 $total_round);do
                echo "$index,${JOB_BATCH_NAME_ARRAY[$index]}" >> $tmpfile_expansion 
            done
        fi 
        _yellow "round list:"
        $(dirname $0)/bin/catcsv.sh $tmpfile_expansion | sed 1d 
        rm -f $tmpfile_expansion 
        [[ $round_list == "True" ]] && _show_rbd_expansion && exit 0 || _waiting "reading" 5
    fi
}
##############################################################################################
# cluster test action decomposition
##############################################################################################
# this part function by assigning different tasks to different individuals
function _parse_host_info(){
# input : host_group_name
# parsing from global array 
#     host_user, host_port, ip_list,
#     fio_cmd, 
#     job_group_name bs pattern 
    if [[ -z $1 ]] ;then
        if [[ -n $host_group_name ]] ;then
            current_host_group="$host_group_name"
        else
            echo "${FUNCNAME[@]} : no host group name recived"
            continue
        fi
    else
        current_host_group="$1"
        host_user="${HOST_GROUP_USER_ARRAY[$current_host_group]}"
        host_port="${HOST_GROUP_PORT_ARRAY[$current_host_group]}"
        bknd_grps="${HOST_GROUP_BKND_ARRAY[$current_host_group]}"
        bknd_mode="${HOST_GROUP_SH_MODE_ARRAY[$current_host_group]}"
          ip_list="${HOST_GROUP_IP_LIST_ARRAY[$current_host_group]}"
#echo $ip_list
          fio_cmd="${job_batch}"
         num_jobs=$(echo $fio_cmd |awk -F'-numjobs=' '{print$2}' |awk '{print$1}')
         [[ -z $num_jobs ]] && num_jobs=x
   job_group_name="${JOB_BATCH_NAME_ARRAY[$job_batch_index]%%-*}"
         job_name="${JOB_BATCH_NAME_ARRAY[$job_batch_index]#*-}"
        # give info
        echo " host group : $(_yellow "$current_host_group") $(_local_unquiet "  host amount: $(echo $ip_list |wc -w) ") "
        #[[ -n $blk_group_name ]] && _unquiet " blk group:\"$blk_group_name\",job batch num:\"$job_batch_index\",job group name:\"$job_group_name\",job pattern:\"$job_name\""
        if [[ -n $blk_group_name ]] ;then 
            [[ -n $job_group_name ]] && local parse_runtime_info="runtime: ${JOB_RUNTIME_ARRAY[$job_group_name]}"
            _local_unquiet " blk group:\"$blk_group_name\",  blk amount:\"$(echo ${BLK_DEV_ARRAY[$blk_group_name]} |wc -w )\",  blk test mode: $(_yellow $test_mode)"
            _local_unquiet " job group:\"$job_group_name\",  job pattern:\"$job_name\",  $parse_runtime_info "
            #echo ${!JOB_RUNTIME_ARRAY[@]}
            #echo $job_group_name 
        fi
        if [[ -z ${host_user// /} ]] || [[ -z ${host_port// /} ]] || [[ -z ${ip_list// /} ]] ;then
            echo "${FUNCNAME[@]}: group: \"$1\", ssh login info is missing."
            continue || exit 1
        fi
        #remove x_host list from group ip_list
        if [[ -n $x_host_list ]] ;then
            for xh in $x_host_list ;do
                ip_list=${ip_list/$xh/}
            done
        fi
        # info
        if _verbose "groupinfo" ;then
            _waiting "reading" 5
            if [[ $send_fio == "True" ]] && [[ -n $blk_group_name ]] ;then
                echo "blk list : ${BLK_DEV_ARRAY[$blk_group_name]}"
                _waiting "reading blk info" 5
            fi
        fi
    fi
}
##############################################################################################
# actions on a host
##############################################################################################
function _ssh_send(){
#send command info to host when ssh_user, ssh_ip, ssh_port was set
    if [[ $# -lt 1 ]] ;then
        echo "${FUNCNAME[@]} warning: no command info to send!" 
        continue
    else
        #if expect -v &>/dev/null ;then 
        #    $(dirname $0)/bin/login/expect_ssh2vm.exp $host_user $host_ip $host_port 'www.123.com' "$@"
            #exddpect -v &>/dev/null && expect bin/expect_ssh2vm.exp $host_user $host_ip $host_port $host_pwd "$@"
        #else 
            #ssh -n -t -q -o StrictHostKeyChecking=no -o ConnectTimeout=$ssh_timeout -l $host_user $host_ip -p $host_port "$@"
            ssh -n -q -o StrictHostKeyChecking=no -o ConnectTimeout=$ssh_timeout -o PubkeyAuthentication=yes -o PasswordAuthentication=no -o BatchMode=yes -l $host_user $host_ip -p $host_port "$@"
        #fi 
    fi
}
function _send_file(){
    if [[ -n $file_group_list ]] ;then
        _unquiet "  $host_ip send files..."
        if [[ $quiet_mode == "True" ]] ;then
            scp -r -q -o StrictHostKeyChecking=no -o ConnectTimeout=$ssh_timeout -o PubkeyAuthentication=yes -o PasswordAuthentication=no -o BatchMode=yes -P $host_port $file_group_list $host_user@$host_ip:$file_group_destination &>/dev/null 
            local scp_stat=$?
            echo "  $host_ip stat: $scp_stat"
            _update_check_stat $scp_stat $tmpfile_exec 
        else
            scp -r -q -o StrictHostKeyChecking=no -o ConnectTimeout=$ssh_timeout -o PubkeyAuthentication=yes -o PasswordAuthentication=no -o BatchMode=yes -P $host_port $file_group_list $host_user@$host_ip:$file_group_destination && echo "  $host_ip done"
            local scp_stat=$?
            _update_check_stat $scp_stat $tmpfile_exec 
        fi
    #else
    #    [[ $send_fio == "True" ]] && _unquiet "    no files to copy."
    fi
}
function _harvest_file(){
    if [[ -n ${harvest_file_group_list//,/} ]] ;then
        _check_output_dir
        local harvest_dir=$output_dir/$host_ip
        [[ -d $harvest_dir ]] || mkdir -p $harvest_dir &>/dev/null
        _unquiet "  $host_ip harvest files..."
        # one file or dir to harvest
        if [[ ${harvest_file_group_list//,/} == ${harvest_file_group_list} ]] ;then
            if [[ $quiet_mode == "True" ]] ;then
                eval scp -r -q -o StrictHostKeyChecking=no -o ConnectTimeout=$ssh_timeout -P $host_port $host_user@$host_ip:$harvest_file_group_list $harvest_dir/ &>/dev/null                                                        
                local hvst_stat=$?
                echo "  $host_ip stat: $hvst_stat"
                _update_check_stat $hvst_stat $tmpfile_exec 
            else
                eval scp -r -q -o StrictHostKeyChecking=no -o ConnectTimeout=$ssh_timeout -o PubkeyAuthentication=yes -o PasswordAuthentication=no -o BatchMode=yes -P $host_port $host_user@$host_ip:$harvest_file_group_list $harvest_dir && echo "  $host_ip done"
                local hvst_stat=$?
                _update_check_stat $hvst_stat $tmpfile_exec 
            fi
        # multy files
        else
            if [[ $quiet_mode == "True" ]] ;then
                eval scp -r -q -o StrictHostKeyChecking=no -o ConnectTimeout=$ssh_timeout -o PubkeyAuthentication=yes -o PasswordAuthentication=no -o BatchMode=yes -P $host_port $host_user@$host_ip:{$harvest_file_group_list} $harvest_dir/ &>/dev/null                                                        
                local hvst_stat=$?
                echo "  $host_ip stat: $hvst_stat"
                _update_check_stat $hvst_stat $tmpfile_exec 
            else
                eval scp -r -q -o StrictHostKeyChecking=no -o ConnectTimeout=$ssh_timeout -o PubkeyAuthentication=yes -o PasswordAuthentication=no -o BatchMode=yes -P $host_port $host_user@$host_ip:{$harvest_file_group_list} $harvest_dir && echo "  $host_ip done"
                local hvst_stat=$?
                _update_check_stat $hvst_stat $tmpfile_exec 
            fi
        fi
    #else
    #    [[ $send_fio == "True" ]] && _unquiet "    no files to copy."
    fi
}
function _send_cmd(){
    #send cmd to host and format output.
    if [[ -n $CMD ]] ;then
        if [[ $quiet_mode == "True" ]] ;then
            _ssh_send "$CMD " &>/dev/null 
            local cmd_stat=$?
            echo "  $host_ip stat: $cmd_stat"
            _update_check_stat $cmd_stat $tmpfile_exec 
        else 
            if  [[ $p_exec == "True" ]] ;then 
                local tmpfile_exec_host_out=$(mktemp -p $tmpfile_dir)
                #use virtual terminal and recive tty input.
                # echo "$host_ip :"
                ssh -t -q -o StrictHostKeyChecking=no -o ConnectTimeout=$ssh_timeout -o PubkeyAuthentication=yes -o PasswordAuthentication=no -o BatchMode=yes -l $host_user $host_ip -p $host_port "$CMD" 2>&1 |tee $tmpfile_exec_host_out
                local cmd_stat=$?
                _update_check_stat $cmd_stat $tmpfile_exec 
            else 
                local tmpfile_exec_host_out=$(mktemp -p $tmpfile_dir)
                # do not merge output 
                _ssh_send " echo -e \" HOST:\e[34m\$HOSTNAME \e[0m \" "
                _segline "$host_ip  stdout"
                ssh -t -q -o StrictHostKeyChecking=no -o ConnectTimeout=$ssh_timeout -o PubkeyAuthentication=yes -o PasswordAuthentication=no -o BatchMode=yes -l $host_user $host_ip -p $host_port "$CMD" 2>&1 |tee $tmpfile_exec_host_out
                local cmd_stat=$?
                _update_check_stat $cmd_stat $tmpfile_exec 
                _segline "$host_ip cmd end"
                #echo "$host_ip empty $cmd_stat" >> $tmpfile_exec_diff 
                #touch /tmp/empty 
            fi
        #if [[ -n $(cat $tmpfile_exec_host_out) ]] ;then _green not empty ;else  echo empty log file ;fi
            # empty output 
            if [[ $(wc -l <$tmpfile_exec_host_out) -eq 0 ]] ;then 
                    echo "$host_ip $tmpfile_dir/empty $cmd_stat" >> $tmpfile_exec_diff 
                    touch $tmpfile_dir/empty 
            # not empty output 
            else
                local content_sum=$(cat $tmpfile_exec_host_out |md5sum |awk '{print$1}')
                echo "$host_ip $tmpfile_dir/$content_sum $cmd_stat" >> $tmpfile_exec_diff 
                touch $tmpfile_dir/$content_sum
                flock $tmpfile_dir/$content_sum cat $tmpfile_exec_host_out > $tmpfile_dir/$content_sum 
            fi 
            rm -rf $tmpfile_exec_host_out 
        fi 
    #else
    #    _unquiet "    no command to run."
    fi
}
##############################################################################################
function _host_ssh_script(){
    # running script on remote host.
    if [[ -f $1 ]];then
        local script_file=$1
        if ping -c2 $host_ip  &>/dev/null ;then
        # network and ssh connection test.
            if _ssh_send "echo ssh ok" &>/dev/null ;then
                #ssh -t -n -q -o StrictHostKeyChecking=no -o ConnectTimeout=$ssh_timeout -o PubkeyAuthentication=yes -o PasswordAuthentication=no -o BatchMode=yes -l $host_user $host_ip -p $host_port "$@"
                if [[ $quiet_mode == "True" ]] ;then
                    cat $1 | ssh -t -q -o StrictHostKeyChecking=no -o ConnectTimeout=$ssh_timeout -o PubkeyAuthentication=yes -o PasswordAuthentication=no -o BatchMode=yes -l $host_user $host_ip -p $host_port "cat - |bash -s $2" &>/dev/null 
                    local script_stat=$?
                    echo "  $host_ip stat: $script_stat"
                    _update_check_stat $script_stat $tmpfile_script_host_out 
                else
    #                echo "1:$1 2:$2"
                    cat $1 | ssh -t -q -o StrictHostKeyChecking=no -o ConnectTimeout=$ssh_timeout -o PubkeyAuthentication=yes -o PasswordAuthentication=no -o BatchMode=yes -l $host_user $host_ip -p $host_port "cat - |bash -s $2"
                    local script_stat=$?
                    _update_check_stat $script_stat $tmpfile_script_host_out 
                fi
            else
                _sshfail
                _update_check_stat 1 $tmpfile_script_host_out 
            fi
        else
            _pingfail
            _update_check_stat 1 $tmpfile_script_host_out 
        fi
    else
        _red "script file: $1 missing."
    fi
}
function _group_ssh_script(){
# input :
#        $1 host_group_name 
#        $2 script file name 
#          the output file name.
    _tmp_quiet "on"
        _yellow "exec script:"
        _parse_host_info "$1"
        tmpfile_script_host_out=$(mktemp -p $tmpfile_dir)
        echo 0 > $tmpfile_script_host_out 
        for host_ip in $ip_list;do 
            if [[ $p_exec == "True" ]] || [[ $send_fio == "True" ]];then
                _host_ssh_script $2 $3 &
            else
                _host_ssh_script $2 $3
            fi
    #        echo "1:$1 2:$2 3:$3"
        done && wait 
        check_stat=$(sort -nr $tmpfile_script_host_out |head -1)
        rm -rf $tmpfile_script_host_out
        _unquiet "$1: execute script done." || echo " group stat : $check_stat"
    _tmp_quiet "off"
}
function _group_ssd_cpid(){
# input :
#        $1 host_group_name 
#        $2 ssh_passwd 
    if [[ -n $ssh_passwd ]] ;then 
        _tmp_quiet "on"
        _yellow "initializing ssh connections:"
        _parse_host_info "$1"
        tmpfile_init_host_out=$(mktemp -p $tmpfile_dir)
        echo 0 > $tmpfile_init_host_out 
        for host_ip in $ip_list;do 
            if ping -c2 $host_ip  &>/dev/null ;then
                # network and ssh connection test.
                timeout $[ssh_timeout * 2] sshpass -p $ssh_passwd ssh-copy-id -o StrictHostKeyChecking=no -o ConnectTimeout=$ssh_timeout $host_user@$host_ip -p $host_port 
                local init_stat=$?
                [[ $init_stat -ne 0 ]] &&  _sshfail
                _update_check_stat $init_stat $tmpfile_init_host_out 
            else
                _pingfail 
                _update_check_stat 1 $tmpfile_init_host_out 
            fi 
        done && wait 
        check_stat=$(sort -nr $tmpfile_init_host_out |head -1)
        rm -rf $tmpfile_init_host_out
        _unquiet "$1: initialization done." || echo " group stat : $check_stat"
        _tmp_quiet "off"
    else
        echo "$1: ssh password not specified, skip initializing."
    fi
}
####################################################
# change for a different backend change this part
####################################################
function _record_bknd(){
# $1 host_group_name 
# works when bknd_grps/bknd_mode were set
# run script on certain host group and there output will be collected with a name like: blk_group_name host_group_name job_group_name / pattern_name bknd_host script_name '.log' 
# collect backend info like tcmu and ceph
    _yellow "check bknd:"
    _parse_host_info "$1"
    # check bknd group name
    _verbose "bkndinfo" && _waiting "reading" 5
    if [[ -n $bknd_grps ]] && [[ $bknd_grps != "none" ]] ;then 
        if [[ -n ${JOB_RUNTIME_ARRAY[$job_group_name]} ]] ;then 
            bknd_runtime="${JOB_RUNTIME_ARRAY[$job_group_name]}"
        else
            echo "job group $job_group_name, job runtime value empty!"
            exit 1
        fi
#---------|add needed info which you want to pass to your script|-----------------------
        #local bknd_sh_pass_in='' 
        local bknd_sh_pass_in=$bknd_runtime 
#----------------------------------------------------------------
        for bknd_grp in $bknd_grps ;do 
            # get host group info format 
            _group_check $bknd_grp 
            # get script info
            local bknd_mode=${HOST_GROUP_SH_MODE_ARRAY[$bknd_grp]}
            # check config file and content
            local bknd_sh_conf=$(dirname $0)/conf/$bknd_grp'.bsh'
            if [[ -f $bknd_sh_conf ]] ;then
                local bknd_sh_list=$(grep -vE "^$|^#" $bknd_sh_conf)
                if [[ -z ${bknd_sh_list// /} ]] ;then 
                    _red "  bknd group:$bknd_grp script list conf empty, skiped."
                    continue
                fi 
            else
                _red "  bknd group:$bknd_grp scripts list file missing, skiped."
                continue 
            fi
            # run script 
            if [[ $bknd_mode == "local" ]] ;then
                for i in ${bknd_sh_list} ;do
                    bash $i $bknd_sh_pass_in &>/dev/null &
                done
            elif [[ $bknd_mode == "remote" ]] ;then 
                for i in ${bknd_sh_list} ;do
                    _group_ssh_script "$bknd_grp" "$i" "$bknd_sh_pass_in"
                done 
            fi
        done
    fi
}
##############################################################################################
function _host_fio_check(){
    if ping -c1 $host_ip &>/dev/null ;then
        # wait five secends, let fio start its jobs
        sleep 5
    else
        _pingfail 
        #_error_interrupt
    fi
    while _ssh_send 'ps aux |grep fio |grep filename |grep -qv grep ' ;do
        _verbose  hostinfo && _waiting "reading" 5
        sleep 5
    done
    while _ssh_send 'ps aux |grep fio |grep rbdname |grep -qv grep ' ;do
        _verbose  hostinfo && _waiting "reading" 5
        sleep 5
    done
}
function _send_fio(){
# send fio job and collect backend server info.
# no input
# works when:
#       blk_group_name was set
#       job batch info was set
#       host ssh info was set
#       bknd ssh info was set
#       and so on ...
    if [[ $send_fio == "True" ]] ;then
        if [[ ! -d $output_dir ]] ;then
            mkdir -p $output_dir
        fi
        # check if multy blkgroup/jobgroup
        [[ $multy_blk_group == "True" ]] && local path_flyover=$blk_group_name
        [[ $multy_job_group == "True" ]] && local path_flyover+=/$job_group_name 
        #log_dir
        if [[ -n path_flyover ]];then
            #
            log_dir="$output_dir/$path_flyover/$blk_group_name-$job_group_name-$current_host_group-$host_ip"
        else 
            #
            log_dir="$output_dir/$blk_group_name-$job_group_name-$current_host_group-$host_ip"
        fi
        # mkdir 
        [[ -d $log_dir ]] ||  mkdir -p $log_dir
        # record info for analysing
        [[ -f $log_dir/fio-batch'.log' ]] || echo -e "bs:\npattern:\nblk:\n" >$log_dir/fio-batch".log"
#sleep 20
        if _ssh_send "fio -v" &>/dev/null ;then
            # log on remote host
            _ssh_send "mkdir -p $log_dir"
            if [[ $rbd_mode == "True" ]] ;then 
                local host_blk_list=${HOST_GROUP_RBD_DEV_ARRAY[$host_ip]}
            else 
                local host_blk_list=${BLK_DEV_ARRAY[$blk_group_name]}
            fi 
#    pdebug=True 
#    _rbd_expansion 
#_marker "dev info"
#    echo ${HOST_GROUP_RBD_DEV_ARRAY[*]}
#    echo ${!HOST_GROUP_RBD_DEV_ARRAY[*]}
#    pdebug=False 
# sleep 30 
            for BLK in $host_blk_list 
            do
                # check blk file
                if _ssh_send "ls $BLK" &>/dev/null ;then
                    log_name=$job_name-${BLK//\//}".log.json"
                    # check sata disk with smartctl, nvme disks are not supported
                    local blk_name=${BLK##*/}
                    if [[ $rbd_mode == "True" ]] ;then
                        local tag=$num_jobs-$host_ip-rbd  
                        # skip rbd check   
                        #:
                    elif [[ ${blk_name//nvme/} != "${blk_name}" ]] ;then
                        local tag=$num_jobs-$host_ip-nvme 
                        # skip nvme
                        #:
                    else
                        local tag=$num_jobs-$host_ip-hdd  
                        if [[ $(_ssh_send "smartctl -V &>/dev/null ;echo \$?") -eq 0 ]] ;then
                            # if smartmontools installed, check status.
                            blk_stats=$(_ssh_send "smartctl -H $BLK |grep 'SMART Health Status:' |awk '{print\$NF}' ")
                            [[ $blk_stats != "OK" ]] && _verbose &&"info: $host_ip \"$BLK\" smartmontools check failed."
                        fi
                    fi 
                elif [[ $rbd_mode == "True" ]] ;then
                    local tag=$num_jobs-$host_ip-rbd 
                    log_name=$job_name-${BLK//\//}".log.json"
                    #
                    _verbose && echo "log name: $log_name"
                else
                    #_red "host: $host_ip, blk or file : \"$BLK\" is not available on host!"
                    _devfail 
                    _verbose "jobinfo"
                fi
                # ready to send
                # update data size to a random value 
#---------|add random info which you want to add |-----------------------
                # local rand_arg="-iodepth=${RANDOM:0:1}"
#------------------------------------------------------------------------
                if [[ ${JOB_DATA_SIZE_ARRAY[$job_group_name]} == "random"  ]] ;then
                    local size_info="-size=$(($RANDOM%100+1))%"
                fi
                _verbose "jobinfo" && _waiting "reading" 15
                    # wait previous 
                if [[ $rbd_mode == "True" ]];then 
                    [[ $test_mode == "single" ]] && _host_fio_check 
                    _ssh_send "$fio_cmd $size_info $rand_arg -rbdname=$BLK -name=$tag-$log_name  --output=$log_dir/$log_name &>>$log_dir/fio-err.log &"
                    echo $job_batch_index $(date +%Y%m%d_%H:%M:%S) "$fio_cmd $size_info $rand_arg -rbdname=$BLK -name=$tag-$log_name   --output=$log_dir/$log_name &>>$log_dir/fio-err.log &" >>$log_dir/fio-batch".log"
                else 
                    [[ $test_mode == "single" ]] && _host_fio_check 
                    _ssh_send "$fio_cmd $size_info $rand_arg -filename=$BLK -name=$tag-$log_name  --output=$log_dir/$log_name &>>$log_dir/fio-err.log &"
                    echo $job_batch_index $(date +%Y%m%d_%H:%M:%S) "$fio_cmd $size_info $rand_arg -filename=$BLK -name=$tag-$log_name  --output=$log_dir/$log_name &>>$log_dir/fio-err.log &" >>$log_dir/fio-batch".log"
                fi
                #record job bs, pattern, blk
                #bs info
                grep  "^bs:.*$" $log_dir/fio-batch".log" \
                |grep -q ",${job_name%-*}" \
                || sed -i "s/^bs:.*$/&\,${job_name%-*}/g" $log_dir/fio-batch".log"
                #pattern info
                grep  "^pattern:.*$" $log_dir/fio-batch".log" \
                |grep -q ",${job_name#*-}" \
                || sed -i "s/^pattern:.*$/&\,${job_name#*-}/g" $log_dir/fio-batch".log"
                #blk info
                grep "^blk:.*$" $log_dir/fio-batch".log" \
                |grep -q ",${BLK//\//}"  \
                || sed -i "s/^blk:.*$/&\,${BLK//\//}/g" $log_dir/fio-batch".log"
            #
            done
        else
            _update_check_stat 1 $tmpfile_exec
            _red "   $host_ip, fio is not ready !"
        fi 
    fi
}  
##############################################################################################
# job task delivery
##############################################################################################
# host
function _exec_with_job(){
# file , cmd , fio
    _send_file
    # action after send files
    _verbose && _blue "execut emode:$execute_mode"
    if [[ $execute_mode == "After" ]] ;then
        _unquiet "command running first."
        #command first
        _send_cmd && wait && _send_fio
    else
        _send_fio && wait && _send_cmd
    fi
}
# host
function _exec_only_oth(){
# file , cmd 
# exec in parallel too
    if [[ $p_exec == "True" ]] ;then
        _send_file && _send_cmd && _harvest_file & 
    else
    #send cmd sequentially
        _send_file
        _send_cmd
        _harvest_file
    fi
}
# host
function _exec_all(){
    if ping -c2 $host_ip &>/dev/null ;then
        #
        if _ssh_send " echo \$(whoami) " &>/dev/null ;then
        # file , cmd , fio
            if [[ $send_fio == "True" ]] ;then
                # put fio in bg, no need to wait and skip to next host immediately.
                _exec_with_job &
            else
            # file , cmd 
                _exec_only_oth
            fi
        else
            _sshfail 
            _update_check_stat 1 $tmpfile_exec
        fi && wait
        #_unquiet "  host:$host_ip distribution done "
    else
        _pingfail 
        #_error_interrupt
        _update_check_stat 1 $tmpfile_exec
    fi
}
function _count_return(){
    # ip + filename + result sum value + cmd_stat 
    # calculate output of different host  
    local sum_list=$(awk '{print$2}' $tmpfile_exec_diff |sort -u )
    local sn=0
    for k in $sum_list ;do
        sn=$[sn + 1]
        # count content_sum 
        local host_k="$(grep $k $tmpfile_exec_diff |awk '{print$1}')"
        # give ip list which share a same content_sum
        local host_num_k=$(grep $k $tmpfile_exec_diff |wc -l )
        # output this type of content 
        _yellow "\n $host_num_k host returned as No. $sn"
        for i in ${host_k};do echo -ne "$i\t" ;done ;echo ""
        _segline "output No. $sn"
            cat $k 
        _segline "end of No. $sn "
        echo ""
        # rm tmpfile 
    done 
}
function _group_execute(){
# files/command/jobs was set
# blk_group_name was set (when lunch a test on cluster.)
# host_group_name was set
    _yellow "execute:"
    _parse_host_info "$1"
        local tmpfile_exec=$(mktemp -p $tmpfile_dir)
        [[ -z $tmpfile_exec_diff ]] && local tmpfile_exec_diff=$(mktemp -p $tmpfile_dir)
        # test host 
        echo 0 > $tmpfile_exec
        for host_ip in $ip_list ;do
             #ping check
             if [[ $p_exec == "True" ]] || [[ $send_fio == "True" ]] ;then
                 _exec_all &
             else
                 _exec_all 
             fi
        done && wait 
        # read stat after all exec done
        check_stat=$(sort -nr $tmpfile_exec |head -1)
        # show different output 
        [[ $quiet_mode != "True" ]] && _count_return
        # clean up tmp file 
        for k in $(awk '{print$2}' $tmpfile_exec_diff) ;do 
            [[ -f /tmp/$k ]] && rm -f /tmp/$k
        done 
#cat $tmpfile_exec_diff
        rm -rf $tmpfile_exec $tmpfile_exec_diff
        #unset tmpfile_exec_diff 
        #if some failed, read done, show status
        [[ $check_stat -eq 1 ]] && echo "$1 group execution partially failed." && _error_interrupt
    _unquiet "$1: execute action done." || echo " group stat : $check_stat"
}
function _host_fio_list(){
    if ping -c1 $host_ip &>/dev/null ;then 
        if _ssh_send 'echo ok' &>/dev/null ;then
            tmpfile=$(mktemp -p $tmpfile_dir)
            tmpfile2=$(mktemp -p $tmpfile_dir)
            host_stat=0
            host_name=$(_ssh_send 'echo $HOSTNAME')
            [[ ${#host_name} -gt 18 ]] && host_name="${host_name:0:18}.."
            # get args info
            local blk_keywd="filename"
            if _ssh_send "ps aux |grep fio |grep rbdname  |grep -vq grep" ;then
                local blk_keywd="rbdname"
            fi
            _ssh_send "ps aux|grep fio|grep $blk_keywd |grep -v grep" > $tmpfile
            # get time info
            _ssh_send "ps -aeo user,pid,etimes,args|grep fio|grep $blk_keywd|grep -v grep |awk '{for(i=3;i<4;i=i+1){printf \$i\" \"};printf \"\n\"}'|sort -u"  > $tmpfile2
            no_job=$(wc -l < $tmpfile) 
            job_pattern=$(awk -F "rw=" '{print$2}' $tmpfile |awk '{print$1}'|sort -u |sed ':label;N;s/\n/\ /;t label')
            job_bs=$(awk -F " -bs=" '{print$2}' $tmpfile |awk '{print$1}'|sort -u |sed ':label;N;s/\n/\ /;t label')
            max_runtime=$(awk -F "runtime=" "{print\$2}" $tmpfile|awk "{print\$1}"|sort -u |head -1)
            disk_list=$(awk -F"$blk_keywd=" '{print$2}' $tmpfile|awk '{print$1}'|sed 's/\/dev\///g' |sort -u |sed ':label;N;s/\n/\ /;t label')
            no_disk=$(awk -F"$blk_keywd=" '{print$2}' $tmpfile|awk '{print$1}' |sort -u |wc -l)
            # nojobs running
            [[ -z $job_pattern ]] && job_pattern="none"
            # mixed read and write, no bs
            if [[ -z ${job_bs// /} ]] ;then
               job_bs=$(awk -F " -bssplit=" '{print$2}' $tmpfile |awk '{print$1}'|sort -u |sed ':label;N;s/\n/\ /;t label') 
               if [[ -n ${job_bs// /} ]] ;then
                   job_bs="mixed"
               else
                   job_bs="none"
               fi
            fi
            if [[ -z "$max_runtime" ]] ;then
                max_runtime="0"
                time_left="0"
            else
                # latest start time
                time_gone=$(sort -n $tmpfile2 |grep -v [a-z,A-Z] |head -1 )
                time_left=$(echo $max_runtime $time_gone |awk '{print$1 - $2}')
                # change format to readable.
                time_left=$(_unit_time "$time_left")
                max_runtime=$(_unit_time "$max_runtime")
            fi
            [[ -z "$disk_list" ]] && disk_list="none"
            #output
        else
            host_stat=1
            host_name='ssh inaccessible :('
        fi 
    else
            host_stat=1
            host_name='ip unreachable :('
    fi
        # check done
        if [[ $host_stat -eq 1 ]] ;then
            check_stat=1
            no_job='-' ;max_runtime='-' ;time_left='-' ;job_bs='-' ;job_pattern='-';no_disk='-' ;disk_list='-'
            printf "\e[1;31m%-21s%-16s%-6s%-12s%-12s%-8s%-11s%-9s%-30s\n\e[0m" "$host_name" "$host_ip" "$no_job" "$max_runtime" "$time_left" "$job_bs" "$job_pattern" "$no_disk" "$disk_list"
        else
            printf "%-21s%-16s%-6s%-12s%-12s%-8s%-11s%-9s%-30s\n" "$host_name" "$host_ip" "$no_job" "$max_runtime" "$time_left" "$job_bs" "$job_pattern" "$no_disk" "$disk_list"
        fi
        rm -rf $tmpfile $tmpfile2 
}
function _group_fio_list(){
# list job on a host group
    _yellow "job list:"
    _parse_host_info "$1"
    # |host name | host ip | No. of jobs | max runtime | disk/file in use | bs | rw pattern | disk/file list |
    printf "%-21s%-16s%-6s%-12s%-12s%-8s%-11s%-9s%-30s\n" "host-name" "host-ip" "jobs" "max-runtime" "max-remain" "bs-size" "rw-pattern" "blk/file" "blk/file-list"
    # get and print job info .
    #    check_stat=0
    for host_ip in $ip_list ;do
        if [[ $p_exec == "True" ]];then
            _host_fio_list &
        else
            _host_fio_list
        fi
    done && wait
#    [[ $check_stat -eq 1 ]] && _error_interrupt
#    _unquiet "list action done." || echo -e "\tstat: $check_stat"
}
##############################################################################################
function _group_fio_log_harvest(){
# blk_group_name was set (when lunch a test on cluster.)
# host_group_name was set
    _yellow "harvest log:"
    # check outputdir name 
    if [[ -n $output_dir  ]] ;then
        _parse_host_info "$1"
            tmpfile_hvst=$(mktemp -p $tmpfile_dir)
            echo 0 > $tmpfile_hvst
            for host_ip in $ip_list ;do
                #ping check
                if ping -c2 $host_ip &>/dev/null ;then
                    if _ssh_send " echo \$(whoami) " &>/dev/null ;then
    #echo "output_dir $output_dir"
    #sleep 30
                        # stop scp from coping "/" from remote, when output dir missing
                        if [[ -n $output_dir ]] && [[ $output_dir != '/' ]] ;then
                            scp -q -r -o StrictHostKeyChecking=no -o ConnectTimeout=$ssh_timeout -o PubkeyAuthentication=yes -o PasswordAuthentication=no -o BatchMode=yes -P $host_port $host_user@$host_ip:$output_dir/* $output_dir/ 
                            _update_check_stat $? $tmpfile_hvst 
                            # wait
                            _ssh_send "rm -rf $output_dir/"
                            _update_check_stat $? $tmpfile_hvst 
                        else
                            _red "output directory err!" && _verbose "jobinfo"
                            _update_check_stat 1 $tmpfile_hvst 
                        fi
                    else
                        _sshfail 
                        _update_check_stat 1 $tmpfile_hvst 
                    fi
                else
                    _pingfail 
                    #_error_interrupt
                    _update_check_stat 1 $tmpfile_hvst
                fi &
            done && wait
        check_stat=$(sort -nr $tmpfile_hvst |head -1)
        rm -rf $tmpfile_hvst
    #    if [[ -f $tmpfile_exec ]] && [[ $check_stat == 1 ]] ;then
    #        _update_check_stat 1 $tmpfile_exec
    #    fi
        [[ $check_stat -ne 0 ]] && echo "$1 log harvest partially failed." && _error_interrupt
        _unquiet "$1: log harvest done." || echo " group stat : $check_stat"
    else
        _red "empty output dir" && _verbose "jobinfo"
    fi
}
#function _fio_scale_watch(){}

function _group_fio_stop(){
# stop all existing fio jobs on host group
    _yellow "fio stop:"
    _parse_host_info "$1"
        tmpfile_stop=$(mktemp -p $tmpfile_dir)
        echo 0 >$tmpfile_stop
        for host_ip in $ip_list ;do
            if ping -c2 $host_ip &>/dev/null ;then
                if _ssh_send 'echo ssh ok' &>/dev/null ;then
                    if _ssh_send 'ps aux |grep fio|grep filename |grep -v grep' &>/dev/null ;then
                        _ssh_send 'kill $(ps aux |grep fio|grep filename |grep -v grep|awk "{print\$2}") ' \
                        && _unquiet " $(_blue "host: $host_ip") fio process killed successfully."
                    else
                        _unquiet " $(_blue "host: $host_ip") no fio running"
                    fi
                else
                    _sshfail 
                fi
            else
                _pingfail 
                #_error_interrupt
                echo 1 >$tmpfile_stop
            fi &
# if run in backgroud return will always be 0
        done && wait
        check_stat=$(cat $tmpfile_stop)
        [[ $check_stat -eq 1 ]] && _error_interrupt
    _unquiet "$1: round stop action done." || echo "stop stat: $check_stat" 
}

# stop test on a group
function _group_test_stop(){
    _yellow "test stop:"
    _parse_host_info "$1"
# stop all background test process on local host
    echo "  stop main test process..."
    local main_pid=$(ps aux |grep '\-\-'fio'\ ' |grep "$1" |grep -v grep |awk '{print$2}')
    [[ -n $main_pid ]] && kill $main_pid || echo "  main process was ended already."
#stop fio jobs
        echo "  stop fio jobs on hosts..."
        tmpfile_stop=$(mktemp -p $tmpfile_dir)
        #echo 0 >$tmpfile_stop
        _update_check_stat 0 $tmpfile_stop
        for host_ip in $ip_list ;do
            # stop local process
            local host_pid=$(ps aux |grep $(whoami) |grep $host_ip |grep ssh |grep fio |grep -v grep |awk '{print$2}')
            [[ -n $host_pid ]] && kill $host_pid 
            # stop fio on host
            if ping -c2 $host_ip &>/dev/null ;then
                if _ssh_send 'echo ssh ok' &>/dev/null ;then
                    if _ssh_send 'ps aux |grep fio|grep -E "filename|rbdname" |grep -v grep' &>/dev/null ;then
                        _ssh_send 'kill $(ps aux |grep fio|grep -E "filename|rbdname" |grep -v grep|awk "{print\$2}") ' \
                        && _unquiet " $(_blue "host: $host_ip") fio process killed successfully."
                    else
                        _unquiet " $(_blue "host: $host_ip") no fio running"
                    fi
                else
                    _sshfail 
                    _update_check_stat 1 $tmpfile_stop
                fi
            else
                _pingfail 
                #_error_interrupt
                #echo 1 >$tmpfile_stop
                _update_check_stat 1 $tmpfile_stop
            fi &
# if run in backgroud return will always be 0
        done && wait
        #check_stat=$(cat $tmpfile_stop)
        check_stat=$(sort -nr $tmpfile_stop |head -1)
        [[ $check_stat -ne 0 ]] && _error_interrupt
    _unquiet "$1: stop action done." || echo "stop stat: $check_stat" 
}

function _group_fio_check(){
# check and wait when fio jobs detected on a given host group
    _yellow "running stat check:"
    _parse_host_info "$1"
        #check_stat=0
       echo " check and wait running fio jobs."
        for host_ip in $ip_list ;do
            _verbose hostinfo && _waiting "reading" 5
            if ping -c1 $host_ip &>/dev/null ;then
            # no fio between 15 secends check, three times of send interval
                if _ssh_send 'whoami' &>/dev/null ;then
                    if _ssh_send 'ps aux |grep fio |grep filename |grep -qv grep ' ;then
                        while _ssh_send 'ps aux |grep fio |grep filename |grep -qv grep ' ;do
                            sleep 30
                        done
                    # rbd test check
                    elif _ssh_send 'ps aux |grep fio |grep rbdname |grep -qv grep ' ;then
                        while _ssh_send 'ps aux |grep fio |grep rbdname |grep -qv grep ' ;do
                            sleep 30
                        done
                    else
                        sleep 15
                        while _ssh_send 'ps aux |grep fio |grep filename |grep -qv grep ' ;do
                            sleep 30
                        done
                        # wait rbd
                        while _ssh_send 'ps aux |grep fio |grep rbdname |grep -qv grep ' ;do
                            sleep 30
                        done
                    fi
                else
                    _sshfail
                fi
            else
                _pingfail 
                #_error_interrupt
            fi &
        done && wait
    #[[ $check_stat -eq 1 ]] && _error_interrupt
    _unquiet "$1: check action done."  # || echo " group stat : $check_stat" 
}
function _group_pre_check(){
# check and wait when fio jobs detected on a given host group
    _yellow "host pre check:"
    _parse_host_info "$1"
#        check_stat=0
        tmpfile_precheck=$(mktemp -p $tmpfile_dir)
        # echo 0 > $tmpfile_precheck
        for host_ip in $ip_list ;do
            _verbose "hostinfo" && _waiting "reading" 5
            # network check
            if ping -c 2 $host_ip &>/dev/null ;then
                if ! _ssh_send 'whoami' &>/dev/null ;then
                    _sshfail 
                    continue 
                fi
                #check fio installation
                if _ssh_send 'fio -v' &>/dev/null ;then
                    _update_check_stat 0  $tmpfile_precheck
                    version=$(_ssh_send "rpm -q fio |awk -F[-.] '{print\$2}'")
                    if [[ -z $version ]] ;then
                        _verbose && _blue "host:$host_ip fio was not installed through rpm/yum."
                        version=$(_ssh_send "fio -v |awk -F[-.] '{print\$2}'")
                    fi
                    if [[ $version -ge 3 ]]  ;then
                        _verbose  &&  echo "  host:$host_ip fio check ok"
                    else
                        _unquiet "$(_yellow "warning"): host:$host_ip fio version: $version, version 3+ will be better."
                    fi
                # no fio installed
                else
                    # check version makecache fast 
                    if _ssh_send 'yum makecache fast >/dev/null' ;then
                        version=$(_ssh_send "yum list fio|grep fio|tail -1|awk '{print \$2}'|cut -d'.' -f1")
                       if [[ $version -ge 3 ]] ;then 
                           _update_check_stat 2  $tmpfile_precheck
                           _blue "host:$host_ip, fio installing.."
                           # fio installing in background 
                           # install fio , makecache 
                           if _ssh_send 'fio -v 2>/dev/null || yum makecache >/dev/null' ;then 
                               _ssh_send 'fio -v 2>/dev/null || yum -y install librbd1 fio &>/dev/null &'
                               # get smartmontools installed
                               _verbose && _ssh_send 'smartctl -V &>/dev/null || yum -y install smartmontools &>/dev/null' & 
                           else
                               _red "host:$host_ip: fio installation, makecache failed"
                               _update_check_stat 1 $tmpfile_precheck
                           fi
                       else 
                           echo "host:$host_ip, fio check failed. (not installed and fio version: $version in available repo is lower than 3)"
                           _update_check_stat 1 $tmpfile_precheck
                       fi
                    else
                        _red "host:$host_ip: fio installation, makecache failed"
                        _update_check_stat 1 $tmpfile_precheck
                    fi
                fi
                # try get rsync installed if possible
                #_ssh_send 'rsync --version || yum -y install rsync' &>/dev/null &
            else
                _pingfail 
                #_error_interrupt
                _update_check_stat 1 $tmpfile_precheck
            fi &
        done && wait
        # abckend process parameters lost  
        check_stat=$(sort -nr $tmpfile_precheck |head -1)
        if grep -q 2 $tmpfile_precheck ;then 
            # if recheck , count number abort at 3
            if [[ -n $recheck ]] ;then 
                # stop recheck after 3 round recheck
                if [[ $recheck -eq 3 ]] ;then 
                    if grep -q 0 $tmpfile_precheck ;then 
                        _red "host group \"$1\" fio installation failed after $recheck round recheck!!"
                        # skip this group and continue 
                        _error_interrupt
                        return 1
                    else
                        _red "ERROR: NO success signal of fio installation recived on \"$1\" ! it is not possible to continue on this group !!"
                        _red "$date abort!"
                        exit 1
                    fi
                else
                    recheck=$[recheck +1] 
                    _yellow "host group $1, fio installation recheck Round_No: $recheck "
                fi
            else
                # first round 
                local recheck=2
                _yellow "check status abnormal, start fio installation recheck ..."
            fi
            # clean tmpfile and recheck 
            rm -rf $tmpfile_precheck
            _yellow "waiting fio installation (yum) ... "
            sleep 20
            _group_pre_check "$1"
        #elif grep -q 1 $tmpfile_precheck ;then
        #    echo check stat : $check_stat 
        fi
        [[ -f $tmpfile_precheck ]] && rm -rf $tmpfile_precheck &>/dev/null 
        # if fio failed, no need to continue
        [[ $check_stat -eq 1 ]] && echo "$1 pre check partially failed." && _timeout 15 && _error_interrupt
    _unquiet "host group $1: pre check action done. group stat : $check_stat " || echo " group $1 stat : $check_stat" 
}
function _group_blk_detect(){
# detected possible target blk on a given host group
    _yellow "group blk detecting:"
    _parse_host_info "$1"
        tmpfile_grp_blk_detected=$(mktemp -p $tmpfile_dir)
        for host_ip in $ip_list ;do
            _verbose "hostinfo" && _waiting "reading" 5
            # network check
            if ping -c 1 $host_ip &>/dev/null ;then
                # ssh check 
                if _ssh_send 'whoami' &>/dev/null ;then
                    tmpfile_host_blk_detected=$(mktemp -p $tmpfile_dir)
                    # get all blk info form ssh 
                    _ssh_send "lsblk -ps" >$tmpfile_host_blk_detected
                    #check blk device     ## do not quote the slash '─', it's not ascii format ! 
                    #local host_blk_detected=$(grep disk $tmpfile_host_blk_detected |grep -v ─ |awk '{print$1}')
                    local host_blk_detected=$(grep disk $tmpfile_host_blk_detected |grep ^'/' |awk '{print$1}')
                    # get root disk info from root partition
                    local host_root_info=($(grep /$ $tmpfile_host_blk_detected))
                    echo ${host_root_info[@]} |grep -q disk || local host_root_info=($(grep /$ -A1 $tmpfile_host_blk_detected|tail -1))
                    echo ${host_root_info[@]} |grep -q disk || local host_root_info=($(grep /$ -A2 $tmpfile_host_blk_detected|tail -1))
                #echo root info: ${host_root_info[@]}
                    local host_root_disk=${host_root_info[0]//[^a-z,'/']/}
                #echo root name: $host_root_disk
                    # get size info of root disk 
                    local host_root_size=$(grep $host_root_disk'\ ' $tmpfile_host_blk_detected |sort -u |awk '{if(NR==1)print$4}' )
                #echo root size: $host_root_size
                    # check if other data disk same size as root (unparted disk)
                    local RootSize_nu=$(grep ^/ $tmpfile_host_blk_detected |grep $host_root_size|grep disk |wc -l)
#               echo same root size disk number: $RootSize_nu
                    local AllDisk_nu=$(grep ^/ $tmpfile_host_blk_detected |grep disk |wc -l)
                    # check all detected disks on host 
                    for i in $host_blk_detected ;do
                        # add new disk when it's not in detected blk dev list.
                        if ! grep -q $i $tmpfile_grp_blk_detected ;then 
                            # check it's size.
                            local tmp_blk_size=$(grep ^$i'\ ' $tmpfile_host_blk_detected |sort -u |awk '{if(NR==1)print$4}')
                            [[ $tmp_blk_size == $host_root_size ]] && local disk_note=" # same size as disk of root partition"
                            # [[ $? -eq 0 ]] && echo $i size $tmp_blk_size
                            echo $i"," "$disk_note" >> $tmpfile_grp_blk_detected  && disk_note=''
                            #only this (one) unparted blk same size as root, and others not  
                            if [[ $tmp_blk_size == $host_root_size  ]] && [[ $RootSize_nu -eq 1 ]] && [[ $AllDisk_nu -ge $RootSize_nu ]] ;then 
                                sed -i "/^${i//\//\\/}/s/^/#/" $tmpfile_grp_blk_detected
                            fi 
                        fi
                    done
                    rm -f $tmpfile_host_blk_detected
                else 
                    _sshfail 
                fi
            else
                _pingfail 
                #_error_interrupt
            fi &
        done && wait 
        #output blk list to group blk configfile 
        echo check done 
        sleep 5
        if [[ ! -f $(dirname $0)/conf/$1".blk" ]] ;then 
            sort -u $tmpfile_grp_blk_detected > $(dirname $0)/conf/$1".blk" 
            sed -i "$ s/\,//g" $(dirname $0)/conf/$1".blk"
            # show detected blk list 
            _yellow "new blk config file: $(dirname $0)/conf/$1.blk"
            cat $(dirname $0)/conf/$1".blk"
        elif ! _format_conf $b_conf |grep -q ^$1 ;then 
            #sed -i "$ s/\,//g" $tmpfile_grp_blk_detected 
            # show detected blk list 
            _yellow "\ncurrently nonpartitioned blk list of group $1:"
            uniq -c $tmpfile_grp_blk_detected
            echo ""
        fi
        # clean tmpfile 
        rm -f $tmpfile_grp_blk_detected
}
function _group_blk_precheck(){
    #check if detected blk available on every host 
    _yellow "group blk recheck:"
    _parse_host_info "$1"
    local grp_blk_conf=$(dirname $0)/conf/$1".blk"
    if [[ -f $grp_blk_conf ]] ;then 
        local blk_list=$(_format_conf $grp_blk_conf)
        if [[ -n $blk_list ]] ;then 
            local blk_list=${blk_list//,/ }
            for host_ip in $ip_list;do
                if ping -c 1 $host_ip &>/dev/null ;then
                    if _ssh_send 'whoami' &>/dev/null ;then
                        #
                        for blk in $blk_list ;do 
                            _ssh_send "lsblk -p $blk" &>/dev/null 
                            if [[ $? -ne 0 ]] || [[ $(_ssh_send "lsblk -p $blk |wc -l") -ne 2  ]] ;then
                                _devfail 
                                grep $blk $grp_blk_conf |grep -q '#' && local blk_fail_note=',' || local blk_fail_note='#invalid for:'
                                grep $blk $grp_blk_conf |grep -q $host_ip || sed -i "/^${blk//\//\\/}/s/$/$blk_fail_note$host_ip/" $grp_blk_conf
                                #sed -i "/^${blk//\//\\/}/s/^/#/" $grp_blk_conf
                            fi 
                            # unset blk after calling _devfail 
                            unset blk 
                        done
                    else
                        _sshfail 
                    fi
                else
                    _pingfail 
                fi &
            done && wait 
            # show blk list after recheck 
            _yellow "currently valid blk list of $1:"
            grep -v "^#" $grp_blk_conf |sed "$ s/\,//g" || _red "  $grp_blk_conf :No valid block device for group: $1 !" 
        else
            _red "  $grp_blk_conf contains no valid block devices."
        fi
    else 
        echo "$grp_blk_conf not exist, skiped"
    fi 
    echo "$1: blk recheck done"
}
function round_report(){
    if [[ -n $job_batch_index ]]; then
        # analise json log
        local   previous_job_group_name="${JOB_BATCH_NAME_ARRAY[$job_batch_index]%%-*}"
        local previous_job_pattern_name="${JOB_BATCH_NAME_ARRAY[$job_batch_index]#*-}"
        # check if multy blkgroup/jobgroup
        local path_flyover=$output_dir 
        [[ $multy_blk_group == "True" ]] && local path_flyover+=/$blk_group_name
        [[ $multy_job_group == "True" ]] && local path_flyover+=/$previous_job_group_name
        # loop through all host, get json file list of last round 
        for host_log_dir  in $(ls $path_flyover/* -d );do 
            # if retest, skip report folder 
            [[ ${host_log_dir##*/} == "_report" ]] && continue 
            for json_file in $(find $host_log_dir -type f -name "$previous_job_pattern_name"*.log.json );do 
                # check format 
                python2 $(dirname $0)/bin/cfiojobs.json.py $json_file &>/dev/null || _red "$json_file : log stat abnormal!"
            done 
        done 
    fi
}
function _list_all_running_jobs(){
    local groups_to_list=$(ps aux |grep $(whoami) |grep -E "\-\-fio|\-\-fio\ " |grep -v grep |awk -F'-g' '{print$2}' |awk '{print$1}' |sort -u)
    if [[ -n $groups_to_list ]] ;then
        for i in $groups_to_list ;do
            bash $0 -g $i --fio-list -p 
        done
    else
        echo "no groups to list"
    fi
}

function _check_output_dir(){
        #check output directory, set default to a datatime stamp.
        if [[ -z $output_dir ]] ;then
            [[ $send_fio == "True" ]] && output_dir="${0#*/}-test-$date" || output_dir="${0#*/}-file-$date"
            _yellow "INFO: no output dir name specified, \"$output_dir\" will be the default name."
        elif [[ -d $output_dir ]] || mkdir -p $output_dir ;then
            :
        else
            [[ $send_fio == "True" ]] && output_dir="${0#*/}-test-$date" || output_dir="${0#*/}-file-$date"
            _red "Warn: the output dir creation failed !" 
            _yellow "INFO: now use \"$output_dir\" as the new output directory, is this ok?"
            _timeout "15"
        fi
}
function _round_stat(){
    local round_stat=$1
    #
    [[ $group_mode == "single" ]] && local g_stat=", GROUP ROUND: $grp_round/$gtotal"
    _yellow "\n$(date "+%Y-%m-%d_%H:%M:%S"): BLK ROUND $bround/$btotal$g_stat, JOB ROUND $job_batch_index/$total_round $round_stat ..."
}
function _execute_job_batch(){
    #local current_host_group=$1
    # $1 host_group_name 
            #send job batchs to host groups
            for job_batch_index in $(seq 1 $total_round) ;do
                # count number and give process info 
                job_batch=${JOB_BATCH_ARRAY[$job_batch_index]}
                # command_mode check 
                [[ $job_batch_index -ge 2 ]] && [[ $command_mode != "always" ]] && CMD=""

                _recover_job_batch

                #exec on all groups
                _round_stat "EXECUTING"
                #print debug 
                _verbose "roundinfo" && _waiting "reading" 5
                if [[ -z $1 ]] && [[ $group_mode == "parallel" ]];then 
                    for host_group_name in $host_group_list ;do
                        _record_bknd $host_group_name 
                        _group_execute $host_group_name 
                    done && wait && _blue "round $job_batch_index all jobs distributed."
                else
                    _record_bknd $1
                    _group_execute $1
                    _blue "round $job_batch_index all jobs distributed."
                fi 

                # check jobs 
                _round_stat "CHECKING"
                _tmp_quiet "on"
                # group mode 
                if [[ -z $1 ]] && [[ $group_mode == "parallel" ]];then 
                    for host_group_name in $host_group_list ;do
                        _group_fio_check $host_group_name 
                        _group_fio_log_harvest $host_group_name 
                    done && wait
                    _blue "###############| Round $job_batch_index ended |################\n"
                else
                    _group_fio_check $1
                    _group_fio_log_harvest $1
                    _blue "###############| Round $job_batch_index ended |################\n"
                fi 
                _tmp_quiet "off"

                # check fio log stat  
                round_report
            done
            #fio jobs distribution done
            # collect logs 
            echo "waiting log collection ..."
            _tmp_quiet "on"
            # scp in background, log harvest in background, check again here
            while ps aux |grep scp |grep -q $output_dir ;do
                sleep 15
            done && wait 
            echo -e "log collection done\n"
}
function _fio_group_report(){
        #build final report of test
        _yellow "\n$(date "+%Y-%m-%d_%H:%M:%S") FIO TEST \"$output_dir\", LOG ANALYSING ..."
        #final_report
        for blk_group_name in $blk_group_list ;do
            # multy blk_group 
            path_flyover=$output_dir 
            [[ $multy_blk_group == "True" ]] && path_flyover+=/$blk_group_name 
            # loop through multy jobgroup 
            if [[ $multy_job_group == "True" ]] ;then 
                for job_group_dir in $(ls $path_flyover/* -d) ;do 
                    python2 $(dirname $0)/bin/cfiojobs.log2.py $job_group_dir
                    [[ $? -ne 0 ]] && _red "dir: \"$job_group_dir\" status abnormal!" 
                done
            else
                python2 $(dirname $0)/bin/cfiojobs.log2.py $path_flyover 
                [[ $? -ne 0 ]] && _red "dir: \"$path_flyover\" status abnormal!" 
            fi
        done
}
function _fio_env_check(){
        _yellow "\n$(date) FIO TEST ENV PRECHECK  ..."
        #network check, software check
        #set blk_group_name empty skip some parse job
        blk_group_name=""
        for host_group_name in $host_group_list;do
            # check host env (recheck after fio package installation)
            _group_pre_check $host_group_name
        done
}

function _fio_conflict_check(){
            #check previous
            _tmp_quiet "on"
            for host_group_name in $host_group_list ;do
                _group_fio_check $host_group_name
            done
            _tmp_quiet "off"
}
function _fio_scale_control(){
            if [[ $group_mode == "single" ]];then 
                grp_round=0
                gtotal=$(echo $host_group_list|wc -w)
                for host_group_name in $host_group_list;do
                    grp_round=$[grp_round +1]
                    [[ $rbd_mode == "True" ]] && _rbd_expansion $host_group_name 
                    _execute_job_batch $host_group_name 
                done
            else
                [[ $rbd_mode == "True" ]] && _rbd_expansion 
                echo "${HOST_GROUP_RBD_DEV_ARRAY[ceph2]}"
                _execute_job_batch 
            fi
}


##############################################################################################
# default blobal options
##############################################################################################
#default options set
function _parameter_set(){

pdebug="False"
conf_check="False"
quiet_mode="False"
list_fio="False"
stop_fio="False"
stop_test="False"
send_fio="False"
host_group_list=""
blk_group_list=""
job_group_list=""
execute_mode="normal"
output_dir=""
test_mode="parallel"
group_mode="parallel"
file_group_list=""
file_group_destination=""
tolerate="False"
p_exec="False"
file_group_list=""
harvest_file_group_list=""
multy_job_group="False"
multy_blk_group="False"
recover_test="False"
recover_blk_group_name=""
recover_job_batch_index=""
command_mode="onece"
rbd_mode="False"
ssd_cpid="False"
#no_sys_blk="False"

}

function _show_info(){
# print all the user options as a rough debug tool
    if [[ $pdebug == "True" ]] ;then
    _yellow " variable stat "
    _blue "\
##################################
function :${FUNCNAME[@]}
info:
      ssd_cpid: $ssd_cpid 
    conf_check: $conf_check
    quiet_mode: $quiet_mode
      list_fio: $list_fio
      stop_fio: $stop_fio
      send_fio: $send_fio
      blk_list: $blk_group_list
      job_list: $job_group_list
     file list: $file_group_list
 harvest_files: $harvest_file_group_list
   destination: $file_group_destination
  execute_mode: $execute_mode
       g group: $host_group_list
       X group: $x_group_list
        x host: $x_host_list
           CMD: $CMD
  command_mode: $command_mode 
    output_dir: $output_dir
  recover_test: $recover_test 
     test_mode: $test_mode
      rbd_mode: $rbd_mode
    group_mode: $group_mode 
    printdebug: $pdebug
      tolerate: $tolerate
     stop_test: $stop_test
##################################"
    #no_sys_blk: $no_sys_blk
_waiting "read info" 10
    [[ -z $host_group_list ]] && _red group empty
                [[ -z $CMD ]] && _red cmd empty
           [[ -z $send_fio ]] && _red send_fio empty
     [[ -z $blk_group_list ]] && _red blk list empty
     [[ -z $job_group_list ]] && _red job list empty
    sleep 2
    fi
}

#############################################################################################
# parameters parse and check, get test arguments info  and command 
#############################################################################################
#options check 
[[ -z $1 ]] &&  _show_help_info && exit 0
_parameter_set
# only individual arguments 
_parse_short_args(){
    #
    while [[ $# -gt 0 ]] ;do
        case "$1" in
            #
        "-v" )
            echo "$0 $script_version"
            exit 0
            ;;
        "-h" )
            _show_help_info
            exit 0
            ;;
        "-e" )
            _make_conf_example
            exit 0
            ;;
        "-l" )
            _list_all_running_jobs
            exit
            ;;
        "-a" )
            _get_all_host_group
            ;;
        "-t" )
            conf_check="True"
            ;;
        "-c" )
            pre_check="True"
            ;;
        "-q" )
            quiet_mode="True"
            ;;
        "-d" )
            pdebug="True"
            ;;
        "-f" )
            tolerate="True"
            ;;
        "-p" )
            p_exec="True"
            ;;
        "-s" )
            test_mode="single"
            ;;
        "-S" )
            group_mode="single"
            ;;
        "-r" )
            rbd_mode="True"
            ;;
        "-A" )
            execute_mode="After"
            ;;
        "-E" )
            command_mode="always"
            ;;
        * )
            _red "Error: wrong format for option \"$1\", please check again!"
            echo "Use \"$0 -h\" to get more help."
            exit 1
            ;;
        esac
        shift 
    done 
}

function _sep_and_parse(){
#    echo "parse: $@"
    while [[ $# -gt 0 ]] ;do
        local alphabet=''
        local args_set=''
        case "$1" in
            "-"* )
                # start with a '-'
                # one letter
                alphabet=${1#*-}
                # one charctor
                if [[ ${#alphabet} -eq 1 ]] ;then 
                    args_set+=' '$1
                    shift 
                    continue
                fi 
                # long combinations of letters 
                # echo all short args : ${#alphabet}
                for i in $(seq 0 $((${#alphabet} -1)) );do 
                    #echo $i -${alphabet:$i:1}
                    args_set+=' -'${alphabet:$i:1}
                    #echo reparse ${alphabet:$i:1}
                done
                ;;
            * )
                # not start with a '-'
                echo "format error: $1 is not an argument!"
                exit 1
                ;;
        esac
        shift
    done
    # do not quote the args set .
    _parse_short_args $args_set
}

#check option calculating result
while [ $# -gt 0 ] ;do
    case "$1" in
        "-g" )
            if [ $# -lt 2 ]
            then
                echo "$0: -g requires a groupname or group list. multi names separated by comma."
                exit 1
            fi
            host_group_list+=" ${2//,/ }"
            shift
            ;;
        "-x" )
            if [ $# -lt 2 ]
            then
                echo "$0: -x requires a hostname or host/ip list. multi names separated by comma."
                exit 1
            fi
            x_host_list+=" ${2//,/ }"
            shift
            ;;
        "-X" )
            if [ $# -lt 2 ]
            then
                echo "$0: -X requires a groupname or group list.  multi names separated by comma."
                exit 1
            fi
            #there will be a uniq element check, so redundant delimiter is fine here
            x_group_list+=" ${2//,/ }"
            shift
            ;;
        "--fio-list" )
            list_fio="True"
            ;;
        "--fio-stop" )
            stop_fio="True"
            ;;
        "--test-stop" )
            stop_test="True"
            ;;
        "--fio" )
            send_fio="True"
            ;;
        "--cpid" )
            ssd_cpid="True"
            ;;
        "--recover" )
            recover_test="True"
            ;;
        "--recover-from" )
            if [ $# -lt 2 ]
            then
                echo "$0: --recover-from requires a Round Number at least"
                exit 1
            fi
            recover_test="True"
            [[ ${2//,/} != ${2} ]] && recover_blk_group_name=${2%,*}
            recover_job_batch_index=${2##*,}
            shift
            ;;
        "--round-list" )
            round_list="True"
            ;;
        "--round-retest" )
            if [ $# -lt 2 ]
            then
                echo "$0: --round-retest requires a Round Number at least"
                exit 1
            fi
            round_retest="True"
            [[ ${2//,/} != ${2} ]] && recover_blk_group_name=${2%,*}
            recover_job_batch_index=${2##*,}
            shift
            ;;
        "-b" )
            if [ $# -lt 2 ]
            then
                echo "$0: -b requires a blk/file group name or a list of that.  multi names separated by comma."
                exit 1
            fi
            blk_group_list+=" ${2//,/ }"
            shift
            ;;
        "-j" )
            if [ $# -lt 2 ]
            then
                echo "$0: -j requires a job group name or a job group list.  multi names separated by comma."
                exit 1
            fi
            job_group_list+=" ${2//,/ }"
            shift
            ;;
        "-o" )
            if [ $# -lt 2 ]
            then
                echo "$0: -o requires an output directory to work."
                exit 1
            fi
            #remove the last "/"
            if [[ ${2:0-1:1} == / ]] 
            then
                output_dir="${2%/*}"
            else
                output_dir="$2"
            fi
            shift
            ;;
        "-F" )
            if [ $# -lt 2 ]
            then
                echo "$0: -F requires a file list.  multi names separated by comma."
                exit 1
            fi
            file_group_list+=" ${2//,/ }"
            shift
            ;;
        "-C" )
            if [ $# -lt 2 ]
            then
                echo "$0: -C requires a file list.  multi names separated by comma."
                exit 1
            fi
            harvest_file_group_list+="${2}"
            shift
            ;;
        "-D" )
            if [ $# -lt 2 ]
            then
                echo "$0: -D requires an output directory to work."
                exit 1
            fi
            #remove the last "/"
            if [[ ${2:0-1:1} == / ]] 
            then
                file_group_destination="${2%/*}"
            else
                file_group_destination="$2"
            fi
            shift
            ;;
        "--script" )
            if [ $# -lt 2 ]
            then
                echo "$0: --script requires a script file list.  multi names separated by comma."
                exit 1
            fi
            script_file_list_list+=" ${2}"
            shift
            ;;
        "--argument" )
            if [ $# -lt 2 ]
            then
                echo "$0: --argument requires a arg list.  multi args should be double quoted."
                exit 1
            fi
            script_argument_list+=" ${2}"
            shift
            ;;
        "--version" )
            echo "$0 $script_version"
            exit 0
            ;;
        * )
            # one word or start with '-'
            if [[ $(echo $1|wc -w) -gt 1 ]] || [[ ${1:0:1} != '-'  ]] ;then 
                #cmd none empty test is needed
                [[ -z $CMD ]] && CMD="$1" || CMD+=" $1"
            else  
                _sep_and_parse "$1"
            fi 
            ;;
    esac
    shift
done


#############################################################################################
# configure file and input options check
#############################################################################################
# after this stage:
# 1. host/blk/job groups are checked.
# 2. usefull inof stored in array.
#running options check
    _show_info
    if [[ $conf_check == "True" ]] ;then 
        _grp_conf_check
        _blk_conf_check
        _job_conf_check
    fi
# check blk group, exit with any wrong name, '-d' skip missing group
        _host_group_check
        #preparation before send fio jobs
        if [[ $send_fio == "True" ]] ;then
            _blk_group_check
            _job_group_check
            _recover_point_check
        else
            #stop job expansion
            blk_stat=2
            job_stat=2
        fi
# confirm blk_stat/grp_stat/job_stat, 0:ok, 1:part failed, 2:all failed.
        if [[ $blk_stat -lt 2 ]] && \
           [[ $job_stat -lt 2 ]] && \
           [[ $grp_stat -lt 2 ]] 
        then
            #job preparation
            _fio_job_expansion
        fi

#############################################################################################
# execute command or start fio test on specified host/blk/job groups
#############################################################################################
# some actions don't need a blk group target.
    # stop fio, list fio, run cmd 
# actions acquire a blk target.
    # send fio


# initialize ssh access 
    if [[ $ssd_cpid == "True" ]] ;then
        read -s -p "Please input host ssh password:" ssh_passwd
        echo "start ssh initializing ..."
        for host_group_name in $host_group_list ;do
            _group_ssd_cpid $host_group_name 
        done
        unset ssh_passwd 
# stop jobs of job round running.
    elif [[ $pre_check == "True" ]] ;then
        echo "start env precheck ..."
        for host_group_name in $host_group_list ;do
            _group_pre_check $host_group_name
            _group_blk_detect $host_group_name
            _group_blk_precheck $host_group_name 
        done
# stop jobs of job round running.
    elif [[ $stop_fio == "True" ]] ;then
        echo "stop fio jobs ..."
        for host_group_name in $host_group_list ;do
            _group_fio_stop $host_group_name
        done
# stop test.
    elif [[ $stop_test == "True" ]] ;then
        echo "stop fio test ..."
        for host_group_name in $host_group_list ;do
            _group_test_stop $host_group_name
        done
# list jobs
    elif [[ $list_fio == "True" ]] ;then
        #
        for host_group_name in $host_group_list ;do
            _group_fio_list $host_group_name
        done
# send files, jobs and cmd
    elif [[ $send_fio == "True" ]] ;then

        #check output directory, set default to a datatime stamp.
        _check_output_dir 
        #check test env for all host groups, fio installation, network reachability, ssh access.
        _fio_env_check 
 
        #send jobs with available blk group
        broud=0
        btotal=$(echo $blk_group_list |wc -w)
        for blk_group_name in $blk_group_list ;do
            bround=$[bround+1]

            # blk group ( round one) info befor start job batch 
            _yellow "\n$(date "+%Y-%m-%d_%H:%M:%S") FIO TEST BLK GROUP: $blk_group_name, PREPARING ..."
            #
            echo -e  "block device group: $(_yellow "$blk_group_name")" 
            _unquiet "dev list : ${BLK_DEV_ARRAY[$blk_group_name]}\n" || echo ""

            _recover_blk_group

            _fio_conflict_check 
            # control group scale and start test on host groups 
            _fio_scale_control 

        done
        #blk group

        # cleanning recover log when test is done 
        rm -f $output_dir/recover.log  
        _fio_group_report 

        # end info
        _yellow "\n$(date "+%Y-%m-%d_%H:%M:%S") FIO TEST FINISHED."

# send files and cmd
    elif [[ -n $CMD ]] || [[ -n $file_group_list ]] || [[ -n $harvest_file_group_list ]] ;then
        # check outputdir 
        [[ -n $harvest_file_group_list  ]] &&  _check_output_dir 
        # run on group 
        for host_group_name in $host_group_list ;do
            # info 
            [[ -n $CMD ]] && _yellow "command: \"$CMD\"\n"
            [[ -n $file_group_list ]] && _yellow "  send files: \"$file_group_list\""
            [[ -n $harvest_file_group_list ]] && _yellow "  harvest files: \"$harvest_file_group_list\""
            # execute 
            _group_execute $host_group_name
        done
        # cleanning 
    elif [[ -n ${script_file_list_list// /} ]] ;then
        #
        for host_group_name in $host_group_list ;do
            _yellow "script: $script_file_list_list"
            [[ -n $script_argument_list ]] && _yellow "argument: $script_argument_list"
            for script_file_name in $script_file_list_list;do
                _group_ssh_script $host_group_name $script_file_name "$script_argument_list" 
            done
        done
    else 
        _yellow "imcomplete agrs recived, nothing to do."
    fi
    _clean_up

#############################################################################################
# how the blk/job/host groups works in this script.
#############################################################################################
# 1. blk_group_name(str)/job_batch(int) will be checked first in the main script,
#    most functions need all blk/job/host info when they were called.
#    fio related functions called by host_group_name,
#    all host group info were stored in a series array like: HOST_GROUP_XXX_ARRAY[host_group_name].
#
# 2. after job batch expansion, all job group info will be contained in a index ARRAY: JOB_BATCH_ARRAY[index]
#
# 3. job_group_name can be regained from JOB_BATCH_NAME_ARRAY[index].
#
# 4. how these info were ognaized
#    blk_group_list   --> each one blk_group_name               --> its blk_list
#    job_group_list   --> each one job_group_name :bs*pattern   --> its job args assemblage
#    host_group_list  --> each one host_group_name              --> its ip_list
#
# 5. how the process sequnce was set.
#       --> blk group(device scale) 
#       --> job batch(bs*pattern*args) --> single job command (test pattern and mode control)
#                                      --> host group (user,port,ip_list;backend server info)  --> single host (run the test)
#    A host in host group will recive :
#      1). file list (-F xxx,xxx -D xxx)
#      2). device list: fio job arguments list (bs + pattern + other arg set of a job group)
#      3). a command list, and these commands will be executed along with the fio jobs.
#############################################################################################
